$OpenBSD: patch-i3bar_src_xcb_c,v 1.17 2015/02/12 08:43:07 dcoppa Exp $

commit 594b29f83d73b9d4a781d2c33cc6fb06f649dc45
Author: Ingo Buerk <ingo.buerk@tngtech.com>
Date:   Wed Feb 11 20:34:43 2015 +0100

Make click events on status blocks work if 'workspace_buttons no' is set.

1. Always subscribe to click events for i3bar.
2. Exit the click event handler if no current workspace was found only after clicks on status blocks have been handled.

commit 4699c714b33afb1c264f3d19911b880267165b94
Author: Michael Stapelberg <michael@stapelberg.de>
Date:   Thu Jul 24 10:09:53 2014 +0200

Bugfix: add a sync call to i3bar to confirm reparents before exiting

Without this call, sometimes the tray icon windows are reparented into
i3's container around the i3bar window, i.e. into the next remaining
window in the window hierarchy. Since i3 then closes that container
(since the i3bar window itself was closed), the tray window will also
get closed. In general, this weird interaction (getting reparented and
then closed) is not well received by tray icon providers).

--- i3bar/src/xcb.c.orig	Sun Jun 15 19:12:43 2014
+++ i3bar/src/xcb.c	Thu Feb 12 09:35:19 2015
@@ -314,18 +314,6 @@ void handle_button(xcb_button_press_event_t *event) {
         return;
     }
 
-    /* TODO: Move this to extern get_ws_for_output() */
-    TAILQ_FOREACH (cur_ws, walk->workspaces, tailq) {
-        if (cur_ws->visible) {
-            break;
-        }
-    }
-
-    if (cur_ws == NULL) {
-        DLOG("No Workspace active?\n");
-        return;
-    }
-
     int32_t x = event->event_x >= 0 ? event->event_x : 0;
     int32_t original_x = x;
 
@@ -364,6 +352,18 @@ void handle_button(xcb_button_press_event_t *event) {
         x = original_x;
     }
 
+    /* TODO: Move this to extern get_ws_for_output() */
+    TAILQ_FOREACH (cur_ws, walk->workspaces, tailq) {
+        if (cur_ws->visible) {
+            break;
+        }
+    }
+
+    if (cur_ws == NULL) {
+        DLOG("No Workspace active?\n");
+        return;
+    }
+
     switch (event->detail) {
         case 4:
             /* Mouse wheel up. We select the previous ws, if any.
@@ -1290,6 +1290,7 @@ void clean_xcb(void) {
     FREE(outputs);
 
     xcb_flush(xcb_connection);
+    xcb_aux_sync(xcb_connection);
     xcb_disconnect(xcb_connection);
 
     ev_check_stop(main_loop, xcb_chk);
@@ -1459,10 +1460,8 @@ void reconfig_windows(bool redraw_bars) {
              * BUTTON_PRESS, to handle clicks on the workspace buttons
              * */
             values[2] = XCB_EVENT_MASK_EXPOSURE |
-                        XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT;
-            if (!config.disable_ws) {
-                values[2] |= XCB_EVENT_MASK_BUTTON_PRESS;
-            }
+                        XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT |
+                        XCB_EVENT_MASK_BUTTON_PRESS;
             xcb_void_cookie_t win_cookie = xcb_create_window_checked(xcb_connection,
                                                                      root_screen->root_depth,
                                                                      walk->bar,
