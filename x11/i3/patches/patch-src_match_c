$OpenBSD: patch-src_match_c,v 1.1 2015/12/18 15:53:09 dcoppa Exp $

Refactor parsing of matches to avoid code duplication.

Fix multiple memory leaks with regular expressions.

--- src/match.c.orig	Wed Sep 30 08:55:10 2015
+++ src/match.c	Fri Dec 18 13:58:58 2015
@@ -238,19 +238,126 @@ bool match_matches_window(Match *match, i3Window *wind
  *
  */
 void match_free(Match *match) {
-    /* First step: free the regex fields / patterns */
     regex_free(match->title);
     regex_free(match->application);
     regex_free(match->class);
     regex_free(match->instance);
     regex_free(match->mark);
     regex_free(match->window_role);
+    regex_free(match->workspace);
+}
 
-    /* Second step: free the regex helper struct itself */
-    FREE(match->title);
-    FREE(match->application);
-    FREE(match->class);
-    FREE(match->instance);
-    FREE(match->mark);
-    FREE(match->window_role);
+/*
+ * Interprets a ctype=cvalue pair and adds it to the given match specification.
+ *
+ */
+void match_parse_property(Match *match, const char *ctype, const char *cvalue) {
+    assert(match != NULL);
+    DLOG("ctype=*%s*, cvalue=*%s*\n", ctype, cvalue);
+
+    if (strcmp(ctype, "class") == 0) {
+        regex_free(match->class);
+        match->class = regex_new(cvalue);
+        return;
+    }
+
+    if (strcmp(ctype, "instance") == 0) {
+        regex_free(match->instance);
+        match->instance = regex_new(cvalue);
+        return;
+    }
+
+    if (strcmp(ctype, "window_role") == 0) {
+        regex_free(match->window_role);
+        match->window_role = regex_new(cvalue);
+        return;
+    }
+
+    if (strcmp(ctype, "con_id") == 0) {
+        char *end;
+        long parsed = strtol(cvalue, &end, 10);
+        if (parsed == LONG_MIN ||
+            parsed == LONG_MAX ||
+            parsed < 0 ||
+            (end && *end != '\0')) {
+            ELOG("Could not parse con id \"%s\"\n", cvalue);
+        } else {
+            match->con_id = (Con *)parsed;
+            DLOG("id as int = %p\n", match->con_id);
+        }
+        return;
+    }
+
+    if (strcmp(ctype, "id") == 0) {
+        char *end;
+        long parsed = strtol(cvalue, &end, 10);
+        if (parsed == LONG_MIN ||
+            parsed == LONG_MAX ||
+            parsed < 0 ||
+            (end && *end != '\0')) {
+            ELOG("Could not parse window id \"%s\"\n", cvalue);
+        } else {
+            match->id = parsed;
+            DLOG("window id as int = %d\n", match->id);
+        }
+        return;
+    }
+
+    if (strcmp(ctype, "window_type") == 0) {
+        if (strcasecmp(cvalue, "normal") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_NORMAL;
+        else if (strcasecmp(cvalue, "dialog") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_DIALOG;
+        else if (strcasecmp(cvalue, "utility") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_UTILITY;
+        else if (strcasecmp(cvalue, "toolbar") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_TOOLBAR;
+        else if (strcasecmp(cvalue, "splash") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_SPLASH;
+        else if (strcasecmp(cvalue, "menu") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_MENU;
+        else if (strcasecmp(cvalue, "dropdown_menu") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_DROPDOWN_MENU;
+        else if (strcasecmp(cvalue, "popup_menu") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_POPUP_MENU;
+        else if (strcasecmp(cvalue, "tooltip") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_TOOLTIP;
+        else
+            ELOG("unknown window_type value \"%s\"\n", cvalue);
+
+        return;
+    }
+
+    if (strcmp(ctype, "con_mark") == 0) {
+        regex_free(match->mark);
+        match->mark = regex_new(cvalue);
+        return;
+    }
+
+    if (strcmp(ctype, "title") == 0) {
+        regex_free(match->title);
+        match->title = regex_new(cvalue);
+        return;
+    }
+
+    if (strcmp(ctype, "urgent") == 0) {
+        if (strcasecmp(cvalue, "latest") == 0 ||
+            strcasecmp(cvalue, "newest") == 0 ||
+            strcasecmp(cvalue, "recent") == 0 ||
+            strcasecmp(cvalue, "last") == 0) {
+            match->urgent = U_LATEST;
+        } else if (strcasecmp(cvalue, "oldest") == 0 ||
+                   strcasecmp(cvalue, "first") == 0) {
+            match->urgent = U_OLDEST;
+        }
+        return;
+    }
+
+    if (strcmp(ctype, "workspace") == 0) {
+        regex_free(match->workspace);
+        match->workspace = regex_new(cvalue);
+        return;
+    }
+
+    ELOG("Unknown criterion: %s\n", ctype);
 }
