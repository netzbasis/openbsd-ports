$OpenBSD: patch-objects_client_c,v 1.16 2016/03/01 11:42:24 dcoppa Exp $

commit 64748671cd8de154092be76e28b4a06080712d76
Author: Uli Schlachter <psychon@znc.in>
Date:   Tue Feb 16 19:31:20 2016 +0100

Don't modify WM_HINTS in client_set_urgent()

To quote from ICCCM (_4.1.2): "The window manager will not change properties
written by the client."

We tried to do this anyway to update WM_HINTS so that the current urgency state
is reflected. Apparently, Chrome does a similar read-modify-set cycle and the
resulting race condition meant that the "accepts input" hint on Chromium's
window was permanently disabled.

This helps with https://github.com/awesomeWM/awesome/issues/670, but I still
think that Chrome shouldn't try to implement "please don't focus me when I do
the following" by temporarily claiming "please don't ever focus me".

Signed-off-by: Uli Schlachter <psychon@znc.in>

commit e54d911a94697eb5fd5b7d5ac2a72e4d3be6194b
Author: Uli Schlachter <psychon@znc.in>
Date:   Sun Feb 28 13:29:25 2016 +0100

Make client key bindings for e.g. xeyes work again

Instead of focusing the root window, we now create a "focus window" inside of
our frame window. This window is placed so that it is not visible, but we can
grab key bindings on it to simulate the window having the input focus.

Fixes: https://github.com/awesomeWM/awesome/issues/699
Signed-off-by: Uli Schlachter <psychon@znc.in>

commit dfe44a15711eef0c236cea48c0ab30ec6bf764a3
Author: Uli Schlachter <psychon@znc.in>
Date:   Thu Feb 4 18:21:25 2016 +0100

Always send ConfigureNotifies

ICCCM specifies when the WM has to send a ConfigureNotify. Java does not care
and wants one all the time. Meh.

Fixes: #248
Signed-off-by: Uli Schlachter <psychon@znc.in>

--- objects/client.c.orig	Sat Jan 30 14:55:18 2016
+++ objects/client.c	Tue Mar  1 11:24:18 2016
@@ -71,22 +71,8 @@ client_set_urgent(lua_State *L, int cidx, bool urgent)
 
     if(c->urgent != urgent)
     {
-        xcb_get_property_cookie_t hints =
-            xcb_icccm_get_wm_hints_unchecked(globalconf.connection, c->window);
-
         c->urgent = urgent;
 
-        /* update ICCCM hints */
-        xcb_icccm_wm_hints_t wmh;
-        xcb_icccm_get_wm_hints_reply(globalconf.connection, hints, &wmh, NULL);
-
-        if(urgent)
-            wmh.flags |= XCB_ICCCM_WM_HINT_X_URGENCY;
-        else
-            wmh.flags &= ~XCB_ICCCM_WM_HINT_X_URGENCY;
-
-        xcb_icccm_set_wm_hints(globalconf.connection, c->window, &wmh);
-
         luaA_object_emit_signal(L, cidx, "property::urgent", 0);
     }
 }
@@ -178,6 +164,16 @@ client_getbywin(xcb_window_t w)
     return NULL;
 }
 
+client_t *
+client_getbynofocuswin(xcb_window_t w)
+{
+    foreach(c, globalconf.clients)
+        if((*c)->nofocus_window == w)
+            return *c;
+
+    return NULL;
+}
+
 /** Get a client by its frame window.
  * \param w The client window to find.
  * \return A client pointer if found, NULL otherwise.
@@ -340,6 +336,20 @@ client_focus(client_t *c)
     globalconf.focus.need_update = true;
 }
 
+static xcb_window_t
+client_get_nofocus_window(client_t *c)
+{
+    if (c->nofocus_window == XCB_NONE) {
+        c->nofocus_window = xcb_generate_id(globalconf.connection);
+        xcb_create_window(globalconf.connection, globalconf.default_depth, c->nofocus_window, c->frame_window,
+                          -2, -2, 1, 1, 0, XCB_COPY_FROM_PARENT, globalconf.visual->visual_id,
+                          0, NULL);
+        xcb_map_window(globalconf.connection, c->nofocus_window);
+        xwindow_grabkeys(c->nofocus_window, &c->keys);
+    }
+    return c->nofocus_window;
+}
+
 void
 client_focus_refresh(void)
 {
@@ -358,11 +368,7 @@ client_focus_refresh(void)
         if(!c->nofocus)
             win = c->window;
         else
-            /* Move the focus away from whatever has it to make sure the
-             * previously focused client doesn't get any input in case
-             * WM_TAKE_FOCUS gets ignored.
-             */
-            win = globalconf.focus.window_no_focus;
+            win = client_get_nofocus_window(c);
 
         if(client_hasproto(c, WM_TAKE_FOCUS))
             xwindow_takefocus(c->window);
@@ -741,13 +747,18 @@ client_resize_do(client_t *c, area_t geometry, bool fo
     bool send_notice = force_notice;
     bool hide_titlebars = c->fullscreen;
     screen_t *new_screen = screen_getbycoord(geometry.x, geometry.y);
+    bool java_is_broken = true;
 
     if (honor_hints)
         geometry = client_apply_size_hints(c, geometry);
 
     if(c->geometry.width == geometry.width
        && c->geometry.height == geometry.height)
+        /* We are moving without changing the size, see ICCCM 4.2.3 */
         send_notice = true;
+    if(java_is_broken)
+        /* Java strong. Java Hulk. Java make own rules! */
+        send_notice = true;
 
     /* Also store geometry including border */
     area_t old_geometry = c->geometry;
@@ -779,7 +790,6 @@ client_resize_do(client_t *c, area_t geometry, bool fo
             (uint32_t[]) { real_geometry.x, real_geometry.y, real_geometry.width, real_geometry.height });
 
     if(send_notice)
-        /* We are moving without changing the size, see ICCCM 4.2.3 */
         client_send_configure(c);
 
     client_restore_enterleave_events();
@@ -1236,6 +1246,8 @@ client_unmanage(client_t *c, bool window_valid)
 
     /* Ignore all spurious enter/leave notify events */
     client_ignore_enterleave_events();
+    if (c->nofocus_window != XCB_NONE)
+        xcb_destroy_window(globalconf.connection, c->nofocus_window);
     xcb_destroy_window(globalconf.connection, c->frame_window);
     client_restore_enterleave_events();
 
@@ -2285,6 +2297,8 @@ luaA_client_keys(lua_State *L)
         luaA_object_emit_signal(L, 1, "property::keys", 0);
         xcb_ungrab_key(globalconf.connection, XCB_GRAB_ANY, c->window, XCB_BUTTON_MASK_ANY);
         xwindow_grabkeys(c->window, keys);
+        if (c->nofocus_window)
+            xwindow_grabkeys(c->nofocus_window, &c->keys);
     }
 
     return luaA_key_array_get(L, 1, keys);
