$OpenBSD: patch-awesome_c,v 1.13 2015/09/07 10:30:01 dcoppa Exp $

commit 0412acfdc02295973e3c216bda6ce4349dc86f80
Author: Uli Schlachter <psychon@znc.in>
Date:   Sun Jul 26 15:59:34 2015 +0200

Keep stacking order across restarts

ReparentWindow puts the window at the top of the stacking order. Thus, we have
to reparent clients back to the root window in the stacking order.

Signed-off-by: Uli Schlachter <psychon@znc.in>

commit 635223b5fe599d94de4ab44d27500041f121e081
Author: Uli Schlachter <psychon@znc.in>
Date:   Sun Jan 11 10:42:45 2015 +0100

Remove titlebars from clients during shutdown

This reparents all clients back to their proper position during shutdown, so
that their top-left corner is now where their titlebar's top-left corner was.
Hopefully, this fixes floating clients moving around across a restart.

Signed-off-by: Uli Schlachter <psychon@znc.in>

commit db087fdda72af25fcfbdf0ca34e349a6e6b3c7fa
Author: Uli Schlachter <psychon@znc.in>
Date:   Sun Jul 26 17:03:10 2015 +0200

Keep client order across restarts

This saves the order of clients in a property called AWESOME_CLIENT_ORDER on the
root window during shutdown. During startup, after managing all existing
windows, we force the client list into the order described by this property
(overwriting any changes that Lua possibly did).

This code should safely handle cases where the property doesn't contain all
existing clients or contains a client which doesn't exist anymore.

Signed-off-by: Uli Schlachter <psychon@znc.in>

commit d37cc7e9dfe968f65752e9dafefdce057862b1a0
Author: Daniel Hahler <git@thequod.de>
Date:   Wed Jul 29 19:04:00 2015 +0200

awesome_atexit: keep client order always

This is not only useful for soft restarts, but also when TERMinating
awesome during development/testing.

The drawback appears to be that it would leak a property on the root
window in case it is really meant to be quit.

Closes https://github.com/awesomeWM/awesome/pull/374.

commit 925e6ecc171bdec65bf1f6ccafea2a0ce1724bf3
Author: Daniel Hahler <git@thequod.de>
Date:   Sat Jun 20 02:08:04 2015 +0200

Make stdout/stderr line buffered

This improves the behaviour with print()ing for debugging, when the
output is redirected to a file.

I was using `setbuf(..., 0)` initially, but it makes sense to buffer it
per line.  This uses `setvbuf` instead of `setlinebuf`, which might not
be available everywhere.

Closes https://github.com/awesomeWM/awesome/pull/267

--- awesome.c.orig	Sat Jan 10 20:36:35 2015
+++ awesome.c	Mon Sep  7 11:41:26 2015
@@ -72,6 +72,23 @@ awesome_atexit(bool restart)
     lua_pushboolean(globalconf.L, restart);
     signal_object_emit(globalconf.L, &global_signals, "exit", 1);
 
+    /* Move clients where we want them to be and keep the stacking order intact */
+    foreach(c, globalconf.stack)
+    {
+        xcb_reparent_window(globalconf.connection, (*c)->window, globalconf.screen->root,
+                (*c)->geometry.x, (*c)->geometry.y);
+    }
+
+    /* Save the client order.  This is useful also for "hard" restarts. */
+    xcb_window_t *wins = p_alloca(xcb_window_t, globalconf.clients.len);
+    int n = 0;
+    foreach(client, globalconf.clients)
+        wins[n++] = (*client)->window;
+
+    xcb_change_property(globalconf.connection, XCB_PROP_MODE_REPLACE,
+                        globalconf.screen->root,
+                        AWESOME_CLIENT_ORDER, XCB_ATOM_WINDOW, 32, n, wins);
+
     a_dbus_cleanup();
 
     systray_cleanup();
@@ -94,6 +111,36 @@ awesome_atexit(bool restart)
     xcb_disconnect(globalconf.connection);
 }
 
+/** Restore the client order after a restart */
+static void
+restore_client_order(xcb_get_property_cookie_t prop_cookie)
+{
+    int client_idx = 0;
+    xcb_window_t *windows;
+    xcb_get_property_reply_t *reply;
+
+    reply = xcb_get_property_reply(globalconf.connection, prop_cookie, NULL);
+    if (!reply || reply->format != 32 || reply->value_len == 0) {
+        p_delete(&reply);
+        return;
+    }
+
+    windows = xcb_get_property_value(reply);
+    for (uint32_t i = 0; i < reply->value_len; i++)
+        /* Find windows[i] and swap it to where it belongs */
+        foreach(c, globalconf.clients)
+            if ((*c)->window == windows[i])
+            {
+                client_t *tmp = *c;
+                *c = globalconf.clients.tab[client_idx];
+                globalconf.clients.tab[client_idx] = tmp;
+                client_idx++;
+            }
+
+    luaA_class_emit_signal(globalconf.L, &client_class, "list", 0);
+    p_delete(&reply);
+}
+
 /** Scan X to find windows to manage.
  */
 static void
@@ -104,6 +151,7 @@ scan(xcb_query_tree_cookie_t tree_c)
     xcb_window_t *wins = NULL;
     xcb_get_window_attributes_reply_t *attr_r;
     xcb_get_geometry_reply_t *geom_r;
+    xcb_get_property_cookie_t prop_cookie;
     long state;
 
     tree_r = xcb_query_tree_reply(globalconf.connection,
@@ -113,6 +161,11 @@ scan(xcb_query_tree_cookie_t tree_c)
     if(!tree_r)
         return;
 
+    /* This gets the property and deletes it */
+    prop_cookie = xcb_get_property_unchecked(globalconf.connection, true,
+                          globalconf.screen->root, AWESOME_CLIENT_ORDER,
+                          XCB_ATOM_WINDOW, 0, UINT_MAX);
+
     /* Get the tree of the children windows of the current root window */
     if(!(wins = xcb_query_tree_children(tree_r)))
         fatal("cannot get tree children");
@@ -167,6 +220,8 @@ scan(xcb_query_tree_cookie_t tree_c)
     }
 
     p_delete(&tree_r);
+
+    restore_client_order(prop_cookie);
 }
 
 static void
@@ -323,6 +378,10 @@ main(int argc, char **argv)
         { "no-argb", 0, NULL, 'a' },
         { NULL,      0, NULL, 0 }
     };
+
+    /* Make stdout/stderr line buffered. */
+    setvbuf(stdout, NULL, _IOLBF, 0);
+    setvbuf(stderr, NULL, _IOLBF, 0);
 
     /* clear the globalconf structure */
     p_clear(&globalconf, 1);
