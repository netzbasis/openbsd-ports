$OpenBSD: patch-awesome_c,v 1.14 2015/11/09 14:36:12 dcoppa Exp $

commit 0412acfdc02295973e3c216bda6ce4349dc86f80
Author: Uli Schlachter <psychon@znc.in>
Date:   Sun Jul 26 15:59:34 2015 +0200

Keep stacking order across restarts

ReparentWindow puts the window at the top of the stacking order. Thus, we have
to reparent clients back to the root window in the stacking order.

Signed-off-by: Uli Schlachter <psychon@znc.in>

commit 635223b5fe599d94de4ab44d27500041f121e081
Author: Uli Schlachter <psychon@znc.in>
Date:   Sun Jan 11 10:42:45 2015 +0100

Remove titlebars from clients during shutdown

This reparents all clients back to their proper position during shutdown, so
that their top-left corner is now where their titlebar's top-left corner was.
Hopefully, this fixes floating clients moving around across a restart.

Signed-off-by: Uli Schlachter <psychon@znc.in>

commit db087fdda72af25fcfbdf0ca34e349a6e6b3c7fa
Author: Uli Schlachter <psychon@znc.in>
Date:   Sun Jul 26 17:03:10 2015 +0200

Keep client order across restarts

This saves the order of clients in a property called AWESOME_CLIENT_ORDER on the
root window during shutdown. During startup, after managing all existing
windows, we force the client list into the order described by this property
(overwriting any changes that Lua possibly did).

This code should safely handle cases where the property doesn't contain all
existing clients or contains a client which doesn't exist anymore.

Signed-off-by: Uli Schlachter <psychon@znc.in>

commit d37cc7e9dfe968f65752e9dafefdce057862b1a0
Author: Daniel Hahler <git@thequod.de>
Date:   Wed Jul 29 19:04:00 2015 +0200

awesome_atexit: keep client order always

This is not only useful for soft restarts, but also when TERMinating
awesome during development/testing.

The drawback appears to be that it would leak a property on the root
window in case it is really meant to be quit.

Closes https://github.com/awesomeWM/awesome/pull/374.

commit 925e6ecc171bdec65bf1f6ccafea2a0ce1724bf3
Author: Daniel Hahler <git@thequod.de>
Date:   Sat Jun 20 02:08:04 2015 +0200

Make stdout/stderr line buffered

This improves the behaviour with print()ing for debugging, when the
output is redirected to a file.

I was using `setbuf(..., 0)` initially, but it makes sense to buffer it
per line.  This uses `setvbuf` instead of `setlinebuf`, which might not
be available everywhere.

Closes https://github.com/awesomeWM/awesome/pull/267

commit 9b5ab994b024a42df38724a093509afe8eb89a8e
Author: Uli Schlachter <psychon@znc.in>
Date:   Wed Sep 23 20:48:56 2015 +0200

Never explicitly focus the root window

Whenever client.focus == nil, we set the input focus to the root window to
express "nothing has the input focus". However, thanks to the way X11 input
works, this means that whatever is under the mouse cursor gets keyboard input
events. This can easily be reproduced with urxvt and some small addition to the
config to unfocus things.

This commit changes things. Instead of focusing the root window, we create a
special "no focus" window that gets focused if we want nothing to have the
focus.

Closes https://github.com/awesomeWM/awesome/pull/470.

Signed-off-by: Uli Schlachter <psychon@znc.in>

commit 821e3e7e2cf1f301f83b790d66452913f92324ef
Author: Uli Schlachter <psychon@znc.in>
Date:   Sat Oct 10 22:25:56 2015 +0200

Make awesome.quit() during startup work

Signed-off-by: Uli Schlachter <psychon@znc.in>

--- awesome.c.orig	Sat Jan 10 20:36:35 2015
+++ awesome.c	Mon Nov  9 13:54:50 2015
@@ -72,6 +72,23 @@ awesome_atexit(bool restart)
     lua_pushboolean(globalconf.L, restart);
     signal_object_emit(globalconf.L, &global_signals, "exit", 1);
 
+    /* Move clients where we want them to be and keep the stacking order intact */
+    foreach(c, globalconf.stack)
+    {
+        xcb_reparent_window(globalconf.connection, (*c)->window, globalconf.screen->root,
+                (*c)->geometry.x, (*c)->geometry.y);
+    }
+
+    /* Save the client order.  This is useful also for "hard" restarts. */
+    xcb_window_t *wins = p_alloca(xcb_window_t, globalconf.clients.len);
+    int n = 0;
+    foreach(client, globalconf.clients)
+        wins[n++] = (*client)->window;
+
+    xcb_change_property(globalconf.connection, XCB_PROP_MODE_REPLACE,
+                        globalconf.screen->root,
+                        AWESOME_CLIENT_ORDER, XCB_ATOM_WINDOW, 32, n, wins);
+
     a_dbus_cleanup();
 
     systray_cleanup();
@@ -94,6 +111,36 @@ awesome_atexit(bool restart)
     xcb_disconnect(globalconf.connection);
 }
 
+/** Restore the client order after a restart */
+static void
+restore_client_order(xcb_get_property_cookie_t prop_cookie)
+{
+    int client_idx = 0;
+    xcb_window_t *windows;
+    xcb_get_property_reply_t *reply;
+
+    reply = xcb_get_property_reply(globalconf.connection, prop_cookie, NULL);
+    if (!reply || reply->format != 32 || reply->value_len == 0) {
+        p_delete(&reply);
+        return;
+    }
+
+    windows = xcb_get_property_value(reply);
+    for (uint32_t i = 0; i < reply->value_len; i++)
+        /* Find windows[i] and swap it to where it belongs */
+        foreach(c, globalconf.clients)
+            if ((*c)->window == windows[i])
+            {
+                client_t *tmp = *c;
+                *c = globalconf.clients.tab[client_idx];
+                globalconf.clients.tab[client_idx] = tmp;
+                client_idx++;
+            }
+
+    luaA_class_emit_signal(globalconf.L, &client_class, "list", 0);
+    p_delete(&reply);
+}
+
 /** Scan X to find windows to manage.
  */
 static void
@@ -104,6 +151,7 @@ scan(xcb_query_tree_cookie_t tree_c)
     xcb_window_t *wins = NULL;
     xcb_get_window_attributes_reply_t *attr_r;
     xcb_get_geometry_reply_t *geom_r;
+    xcb_get_property_cookie_t prop_cookie;
     long state;
 
     tree_r = xcb_query_tree_reply(globalconf.connection,
@@ -113,6 +161,11 @@ scan(xcb_query_tree_cookie_t tree_c)
     if(!tree_r)
         return;
 
+    /* This gets the property and deletes it */
+    prop_cookie = xcb_get_property_unchecked(globalconf.connection, true,
+                          globalconf.screen->root, AWESOME_CLIENT_ORDER,
+                          XCB_ATOM_WINDOW, 0, UINT_MAX);
+
     /* Get the tree of the children windows of the current root window */
     if(!(wins = xcb_query_tree_children(tree_r)))
         fatal("cannot get tree children");
@@ -167,6 +220,8 @@ scan(xcb_query_tree_cookie_t tree_c)
     }
 
     p_delete(&tree_r);
+
+    restore_client_order(prop_cookie);
 }
 
 static void
@@ -324,6 +379,10 @@ main(int argc, char **argv)
         { NULL,      0, NULL, 0 }
     };
 
+    /* Make stdout/stderr line buffered. */
+    setvbuf(stdout, NULL, _IOLBF, 0);
+    setvbuf(stderr, NULL, _IOLBF, 0);
+
     /* clear the globalconf structure */
     p_clear(&globalconf, 1);
     globalconf.keygrabber = LUA_REFNIL;
@@ -499,23 +558,27 @@ main(int argc, char **argv)
     spawn_init();
 
     /* The default GC is just a newly created associated with a window with
-     * depth globalconf.default_depth */
-    xcb_window_t tmp_win = xcb_generate_id(globalconf.connection);
+     * depth globalconf.default_depth.
+     * The window_no_focus is used for "nothing has the input focus". */
+    globalconf.focus.window_no_focus = xcb_generate_id(globalconf.connection);
     globalconf.gc = xcb_generate_id(globalconf.connection);
     xcb_create_window(globalconf.connection, globalconf.default_depth,
-                      tmp_win, globalconf.screen->root,
+                      globalconf.focus.window_no_focus, globalconf.screen->root,
                       -1, -1, 1, 1, 0,
                       XCB_COPY_FROM_PARENT, globalconf.visual->visual_id,
-                      XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_COLORMAP,
+                      XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL |
+                      XCB_CW_OVERRIDE_REDIRECT | XCB_CW_COLORMAP,
                       (const uint32_t [])
                       {
                           globalconf.screen->black_pixel,
                           globalconf.screen->black_pixel,
+                          1,
                           globalconf.default_cmap
                       });
-    xcb_create_gc(globalconf.connection, globalconf.gc, tmp_win, XCB_GC_FOREGROUND | XCB_GC_BACKGROUND,
+    xcb_map_window(globalconf.connection, globalconf.focus.window_no_focus);
+    xcb_create_gc(globalconf.connection, globalconf.gc, globalconf.focus.window_no_focus,
+                  XCB_GC_FOREGROUND | XCB_GC_BACKGROUND,
                   (const uint32_t[]) { globalconf.screen->black_pixel, globalconf.screen->white_pixel });
-    xcb_destroy_window(globalconf.connection, tmp_win);
 
     /* Get the window tree associated to this screen */
     tree_c = xcb_query_tree_unchecked(globalconf.connection,
@@ -547,9 +610,12 @@ main(int argc, char **argv)
     g_main_context_set_poll_func(g_main_context_default(), &a_glib_poll);
     gettimeofday(&last_wakeup, NULL);
 
-    /* main event loop */
-    globalconf.loop = g_main_loop_new(NULL, FALSE);
-    g_main_loop_run(globalconf.loop);
+    /* main event loop (if not NULL, awesome.quit() was already called) */
+    if (globalconf.loop == NULL)
+    {
+        globalconf.loop = g_main_loop_new(NULL, FALSE);
+        g_main_loop_run(globalconf.loop);
+    }
     g_main_loop_unref(globalconf.loop);
     globalconf.loop = NULL;
 
