$OpenBSD: patch-src_core_OCIOYaml_cpp,v 1.1 2014/09/03 11:17:59 pascal Exp $
--- src/core/OCIOYaml.cpp.orig	Wed Oct  9 00:59:34 2013
+++ src/core/OCIOYaml.cpp	Wed Aug 27 13:51:26 2014
@@ -30,635 +30,550 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY O
 
 #include <OpenColorIO/OpenColorIO.h>
 
+#ifndef WINDOWS
+
+// fwd declare yaml-cpp visibility
+#pragma GCC visibility push(hidden)
+namespace YAML {
+    class Exception;
+    class BadDereference;
+    class RepresentationException;
+    class EmitterException;
+    class ParserException;
+    class InvalidScalar;
+    class KeyNotFound;
+    template <typename T> class TypedKeyNotFound;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::ColorSpace>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::Config>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::Exception>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::GpuShaderDesc>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::ImageDesc>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::Look>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::Processor>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::Transform>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::AllocationTransform>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::CDLTransform>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::ColorSpaceTransform>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::DisplayTransform>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::ExponentTransform>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::FileTransform>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::GroupTransform>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::LogTransform>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::LookTransform>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::MatrixTransform>;
+    template <> class TypedKeyNotFound<OCIO_NAMESPACE::TruelightTransform>;
+}
+#pragma GCC visibility pop
+
+#endif
+
+#include <yaml-cpp/yaml.h>
+
 #include "Logging.h"
 #include "MathUtils.h"
+#include "pystring/pystring.h"
+#include "PathUtils.h"
+#include "ParseUtils.h"
+#include "Display.h"
 #include "OCIOYaml.h"
 
 OCIO_NAMESPACE_ENTER
 {
-    ///////////////////////////////////////////////////////////////////////////
-    //  Core
     
-    void LogUnknownKeyWarning(const std::string & name, const YAML::Node& tag)
+    namespace
     {
-        std::string key;
-        tag >> key;
-        
-        std::ostringstream os;
-        os << "Unknown key in " << name << ": ";
-        os << "'" << key << "'. (line ";
-        os << (tag.GetMark().line+1) << ", column "; // (yaml line numbers start at 0)
-        os << tag.GetMark().column << ")";
-        LogWarning(os.str());
-    }
     
-    void operator >> (const YAML::Node& node, ColorSpaceRcPtr& cs)
-    {
-        if(node.Tag() != "ColorSpace")
-            return; // not a !<ColorSpace> tag
+#ifdef OLDYAML
+        typedef YAML::Iterator Iterator;
+#else
+        typedef YAML::const_iterator Iterator;
+#endif
         
-        std::string key, stringval;
-        bool boolval;
+        // Iterator access
         
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        inline const YAML::Node& get_first(const Iterator it)
         {
-            iter.first() >> key;
-            
-            if(key == "name")
-            {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                    cs->setName(stringval.c_str());
-            }
-            else if(key == "description")
-            {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                    cs->setDescription(stringval.c_str());
-            }
-            else if(key == "family")
-            {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                    cs->setFamily(stringval.c_str());
-            }
-            else if(key == "equalitygroup")
-            {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                    cs->setEqualityGroup(stringval.c_str());
-            }
-            else if(key == "bitdepth")
-            {
-                BitDepth ret;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<BitDepth>(ret))
-                    cs->setBitDepth(ret);
-            }
-            else if(key == "isdata")
-            {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<bool>(boolval))
-                    cs->setIsData(boolval);
-            }
-            else if(key == "allocation")
-            {
-                Allocation val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<Allocation>(val))
-                    cs->setAllocation(val);
-            }
-            else if(key == "allocationvars")
-            {
-                std::vector<float> val;
-                if (iter.second().Type() != YAML::NodeType::Null)
-                {
-                    iter.second() >> val;
-                    if(!val.empty())
-                    {
-                        cs->setAllocationVars(static_cast<int>(val.size()), &val[0]);
-                    }
-                }
-            }
-            else if(key == "to_reference")
-            {
-                TransformRcPtr val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformRcPtr>(val))
-                  cs->setTransform(val, COLORSPACE_DIR_TO_REFERENCE);
-            }
-            else if(key == "from_reference")
-            {
-                TransformRcPtr val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformRcPtr>(val))
-                  cs->setTransform(val, COLORSPACE_DIR_FROM_REFERENCE);
-            }
-            else
-            {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
-            }
+#ifdef OLDYAML
+            return it.first();
+#else
+            return it->first;
+#endif
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ColorSpaceRcPtr cs)
-    {
-        out << YAML::VerbatimTag("ColorSpace");
-        out << YAML::BeginMap;
         
-        out << YAML::Key << "name" << YAML::Value << cs->getName();
-        out << YAML::Key << "family" << YAML::Value << cs->getFamily();
-        out << YAML::Key << "equalitygroup" << YAML::Value << cs->getEqualityGroup();
-        out << YAML::Key << "bitdepth" << YAML::Value << cs->getBitDepth();
-        if(strlen(cs->getDescription()) > 0)
+        inline const YAML::Node& get_second(const Iterator it)
         {
-            out << YAML::Key << "description";
-            out << YAML::Value << YAML::Literal << cs->getDescription();
+#ifdef OLDYAML
+            return it.second();
+#else
+            return it->second;
+#endif
         }
-        out << YAML::Key << "isdata" << YAML::Value << cs->isData();
         
-        out << YAML::Key << "allocation" << YAML::Value << cs->getAllocation();
-        if(cs->getAllocationNumVars() > 0)
+        // Basic types
+        
+        inline void load(const YAML::Node& node, bool& x)
         {
-            std::vector<float> allocationvars(cs->getAllocationNumVars());
-            cs->getAllocationVars(&allocationvars[0]);
-            out << YAML::Key << "allocationvars";
-            out << YAML::Flow << YAML::Value << allocationvars;
+#ifdef OLDYAML
+            node.Read<bool>(x);
+#else
+            x = node.as<bool>();
+#endif
         }
         
-        ConstTransformRcPtr toref = \
-            cs->getTransform(COLORSPACE_DIR_TO_REFERENCE);
-        if(toref)
-            out << YAML::Key << "to_reference" << YAML::Value << toref;
+        inline void load(const YAML::Node& node, int& x)
+        {
+#ifdef OLDYAML
+            node.Read<int>(x);
+#else
+            x = node.as<int>();
+#endif
+        }
         
-        ConstTransformRcPtr fromref = \
-            cs->getTransform(COLORSPACE_DIR_FROM_REFERENCE);
-        if(fromref)
-            out << YAML::Key << "from_reference" << YAML::Value << fromref;
+        inline void load(const YAML::Node& node, float& x)
+        {
+#ifdef OLDYAML
+            node.Read<float>(x);
+#else
+            x = node.as<float>();
+#endif
+        }
         
-        out << YAML::EndMap;
-        out << YAML::Newline;
-        
-        return out;
-    }
-    
-    
-    ///////////////////////////////////////////////////////////////////////////
-    
-    // Look. (not the transform, the top-level class)
-    
-    void operator >> (const YAML::Node& node, LookRcPtr& look)
-    {
-        if(node.Tag() != "Look")
-            return;
-        
-        std::string key, stringval;
-        
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        inline void load(const YAML::Node& node, std::string& x)
         {
-            iter.first() >> key;
-            
-            if(key == "name")
-            {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                    look->setName(stringval.c_str());
-            }
-            else if(key == "process_space")
-            {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                    look->setProcessSpace(stringval.c_str());
-            }
-            else if(key == "transform")
-            {
-                TransformRcPtr val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformRcPtr>(val))
-                    look->setTransform(val);
-            }
-            else if(key == "inverse_transform")
-            {
-                TransformRcPtr val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformRcPtr>(val))
-                    look->setInverseTransform(val);
-            }
-            else
-            {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
-            }
+#ifdef OLDYAML
+            node.Read<std::string>(x);
+#else
+            x = node.as<std::string>();
+#endif
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, LookRcPtr look)
-    {
-        out << YAML::VerbatimTag("Look");
-        out << YAML::BeginMap;
-        out << YAML::Key << "name" << YAML::Value << look->getName();
-        out << YAML::Key << "process_space" << YAML::Value << look->getProcessSpace();
         
-        if(look->getTransform())
+        inline void load(const YAML::Node& node, std::vector<std::string>& x)
         {
-            out << YAML::Key << "transform";
-            out << YAML::Value << look->getTransform();
+#ifdef OLDYAML
+            node >> x;
+#else
+            x = node.as<std::vector<std::string> >();
+#endif
         }
         
-        if(look->getInverseTransform())
+        inline void load(const YAML::Node& node, std::vector<float>& x)
         {
-            out << YAML::Key << "inverse_transform";
-            out << YAML::Value << look->getInverseTransform();
+#ifdef OLDYAML
+            node >> x;
+#else
+            x = node.as<std::vector<float> >();
+#endif
         }
         
-        out << YAML::EndMap;
-        out << YAML::Newline;
+        // Enums
         
-        return out;
-    }
-    
-    
-    
-    ///////////////////////////////////////////////////////////////////////////
-    
-    
-    namespace
-    {
-        void EmitBaseTransformKeyValues(YAML::Emitter & out,
-                                        const ConstTransformRcPtr & t)
+        inline void load(const YAML::Node& node, BitDepth& depth)
         {
-            if(t->getDirection() != TRANSFORM_DIR_FORWARD)
-            {
-                out << YAML::Key << "direction";
-                out << YAML::Value << YAML::Flow << t->getDirection();
-            }
+            std::string str;
+            load(node, str);
+            depth = BitDepthFromString(str.c_str());
         }
-    }
-    
-    void operator >> (const YAML::Node& node, TransformRcPtr& t)
-    {
-        if(node.Type() != YAML::NodeType::Map)
+        
+        inline void save(YAML::Emitter& out, BitDepth depth)
         {
-            std::ostringstream os;
-            os << "Unsupported Transform type encountered: (" << node.Type() << ") in OCIO profile. ";
-            os << "Only Mapping types supported. (line ";
-            os << (node.GetMark().line+1) << ", column "; // (yaml line numbers start at 0)
-            os << node.GetMark().column << ")";
-            throw Exception(os.str().c_str());
+            out << BitDepthToString(depth);
         }
         
-        std::string type = node.Tag();
+        inline void load(const YAML::Node& node, Allocation& alloc)
+        {
+            std::string str;
+            load(node, str);
+            alloc = AllocationFromString(str.c_str());
+        }
         
-        if(type == "AllocationTransform") {
-            AllocationTransformRcPtr temp;
-            node.Read<AllocationTransformRcPtr>(temp);
-            t = temp;
+        inline void save(YAML::Emitter& out, Allocation alloc)
+        {
+            out << AllocationToString(alloc);
         }
-        else if(type == "CDLTransform") {
-            CDLTransformRcPtr temp;
-            node.Read<CDLTransformRcPtr>(temp);
-            t = temp;
+        
+        inline void load(const YAML::Node& node, ColorSpaceDirection& dir)
+        {
+            std::string str;
+            load(node, str);
+            dir = ColorSpaceDirectionFromString(str.c_str());
         }
-        else if(type == "ColorSpaceTransform")  {
-            ColorSpaceTransformRcPtr temp;
-            node.Read<ColorSpaceTransformRcPtr>(temp);
-            t = temp;
+        
+        inline void save(YAML::Emitter& out, ColorSpaceDirection dir)
+        {
+            out << ColorSpaceDirectionToString(dir);
         }
-        // TODO: DisplayTransform
-        else if(type == "ExponentTransform")  {
-            ExponentTransformRcPtr temp;
-            node.Read<ExponentTransformRcPtr>(temp);
-            t = temp;
+        
+        inline void load(const YAML::Node& node, TransformDirection& dir)
+        {
+            std::string str;
+            load(node, str);
+            dir = TransformDirectionFromString(str.c_str());
         }
-        else if(type == "FileTransform")  {
-            FileTransformRcPtr temp;
-            node.Read<FileTransformRcPtr>(temp);
-            t = temp;
+        
+        inline void save(YAML::Emitter& out, TransformDirection dir)
+        {
+            out << TransformDirectionToString(dir);
         }
-        else if(type == "GroupTransform") {
-            GroupTransformRcPtr temp;
-            node.Read<GroupTransformRcPtr>(temp);
-            t = temp;
+        
+        inline void load(const YAML::Node& node, Interpolation& interp)
+        {
+            std::string str;
+            load(node, str);
+            interp = InterpolationFromString(str.c_str());
         }
-        else if(type == "LogTransform") {
-            LogTransformRcPtr temp;
-            node.Read<LogTransformRcPtr>(temp);
-            t = temp;
+        
+        inline void save(YAML::Emitter& out, Interpolation interp)
+        {
+            out << InterpolationToString(interp);
         }
-        else if(type == "LookTransform") {
-            LookTransformRcPtr temp;
-            node.Read<LookTransformRcPtr>(temp);
-            t = temp;
-        }
-        else if(type == "MatrixTransform")  {
-            MatrixTransformRcPtr temp;
-            node.Read<MatrixTransformRcPtr>(temp);
-            t = temp;
-        }
-        else if(type == "TruelightTransform")  {
-            TruelightTransformRcPtr temp;
-            node.Read<TruelightTransformRcPtr>(temp);
-            t = temp;
-        }
-        else
+        
+        //
+        
+        inline void LogUnknownKeyWarning(const std::string & name,
+                                         const YAML::Node& tag)
         {
-            // TODO: add a new empty (better name?) aka passthru Transform()
-            // which does nothing. This is so upsupported !<tag> types don't
-            // throw an exception. Alternativly this could be caught in the
-            // GroupTransformRcPtr >> operator with some type of
-            // supported_tag() method
-            
-            // TODO: consider the forwards-compatibility implication of
-            // throwing an exception.  Should this be a warning, instead?
-            
-            //  t = EmptyTransformRcPtr(new EmptyTransform(), &deleter);
+            std::string key;
+            load(tag, key);
+        
             std::ostringstream os;
-            os << "Unsupported transform type !<" << type << "> in OCIO profile. ";
-            os << " (line ";
-            os << (node.GetMark().line+1) << ", column "; // (yaml line numbers start at 0)
-            os << node.GetMark().column << ")";
-            throw Exception(os.str().c_str());
+            os << "Unknown key in " << name << ": '" << key << "'.";
+            LogWarning(os.str());
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ConstTransformRcPtr t)
-    {
-        if(ConstAllocationTransformRcPtr Allocation_tran = \
-            DynamicPtrCast<const AllocationTransform>(t))
-            out << Allocation_tran;
-        else if(ConstCDLTransformRcPtr CDL_tran = \
-            DynamicPtrCast<const CDLTransform>(t))
-            out << CDL_tran;
-        else if(ConstColorSpaceTransformRcPtr ColorSpace_tran = \
-            DynamicPtrCast<const ColorSpaceTransform>(t))
-            out << ColorSpace_tran;
-        else if(ConstExponentTransformRcPtr Exponent_tran = \
-            DynamicPtrCast<const ExponentTransform>(t))
-            out << Exponent_tran;
-        else if(ConstFileTransformRcPtr File_tran = \
-            DynamicPtrCast<const FileTransform>(t))
-            out << File_tran;
-        else if(ConstGroupTransformRcPtr Group_tran = \
-            DynamicPtrCast<const GroupTransform>(t))
-            out << Group_tran;
-        else if(ConstLogTransformRcPtr Log_tran = \
-            DynamicPtrCast<const LogTransform>(t))
-            out << Log_tran;
-        else if(ConstLookTransformRcPtr Look_tran = \
-            DynamicPtrCast<const LookTransform>(t))
-            out << Look_tran;
-        else if(ConstMatrixTransformRcPtr Matrix_tran = \
-            DynamicPtrCast<const MatrixTransform>(t))
-            out << Matrix_tran;
-        else if(ConstTruelightTransformRcPtr Truelight_tran = \
-            DynamicPtrCast<const TruelightTransform>(t))
-            out << Truelight_tran;
-        else
-            throw Exception("Unsupported Transform() type for serialization.");
         
-        return out;
-    }
-    
-    
-    ///////////////////////////////////////////////////////////////////////////
-    //  Transforms
-    
-    void operator >> (const YAML::Node& node, GroupTransformRcPtr& t)
-    {
-        t = GroupTransform::Create();
+        // View
         
-        std::string key;
-        
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        inline void load(const YAML::Node& node, View& v)
         {
-            iter.first() >> key;
+            if(node.Tag() != "View")
+                return;
             
-            if(key == "children")
+            std::string key, stringval;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
             {
-                const YAML::Node & children = iter.second();
-                for(unsigned i = 0; i <children.size(); ++i)
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "name")
                 {
-                    TransformRcPtr childTransform;
-                    children[i].Read<TransformRcPtr>(childTransform);
-                    
-                    // TODO: consider the forwards-compatibility implication of
-                    // throwing an exception.  Should this be a warning, instead?
-                    if(!childTransform)
-                    {
-                        throw Exception("Child transform could not be parsed.");
-                    }
-                    
-                    t->push_back(childTransform);
+                    load(second, stringval);
+                    v.name = stringval;
                 }
+                else if(key == "colorspace")
+                {
+                    load(second, stringval);
+                    v.colorspace = stringval;
+                }
+                else if(key == "looks" || key == "look")
+                {
+                    load(second, stringval);
+                    v.looks = stringval;
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
             }
-            else if(key == "direction")
+            
+            if(v.name.empty())
             {
-                TransformDirection val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformDirection>(val))
-                  t->setDirection(val);
+                throw Exception("View does not specify 'name'.");
             }
-            else
+            if(v.colorspace.empty())
             {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
+                std::ostringstream os;
+                os << "View '" << v.name << "' ";
+                os << "does not specify colorspace.";
+                throw Exception(os.str().c_str());
             }
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ConstGroupTransformRcPtr t)
-    {
-        out << YAML::VerbatimTag("GroupTransform");
-        out << YAML::BeginMap;
-        EmitBaseTransformKeyValues(out, t);
         
-        out << YAML::Key << "children";
-        out << YAML::Value;
-        
-        out << YAML::BeginSeq;
-        for(int i = 0; i < t->size(); ++i)
+        inline void save(YAML::Emitter& out, View view)
         {
-            out << t->getTransform(i);
+            out << YAML::VerbatimTag("View");
+            out << YAML::Flow;
+            out << YAML::BeginMap;
+            out << YAML::Key << "name" << YAML::Value << view.name;
+            out << YAML::Key << "colorspace" << YAML::Value << view.colorspace;
+            if(!view.looks.empty()) out << YAML::Key << "looks" << YAML::Value << view.looks;
+            out << YAML::EndMap;
         }
-        out << YAML::EndSeq;
         
-        out << YAML::EndMap;
+        // Common Transform
         
-        return out;
-    }
-    
-    
-    
-    void operator >> (const YAML::Node& node, FileTransformRcPtr& t)
-    {
-        t = FileTransform::Create();
+        inline void EmitBaseTransformKeyValues(YAML::Emitter & out,
+                                               const ConstTransformRcPtr & t)
+        {
+            if(t->getDirection() != TRANSFORM_DIR_FORWARD)
+            {
+                out << YAML::Key << "direction";
+                out << YAML::Value << YAML::Flow;
+                save(out, t->getDirection());
+            }
+        }
         
-        std::string key, stringval;
+        // AllocationTransform
         
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        inline void load(const YAML::Node& node, AllocationTransformRcPtr& t)
         {
-            iter.first() >> key;
+            t = AllocationTransform::Create();
             
-            if(key == "src")
+            std::string key;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setSrc(stringval.c_str());
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "allocation")
+                {
+                    Allocation val;
+                    load(second, val);
+                    t->setAllocation(val);
+                }
+                else if(key == "vars")
+                {
+                    std::vector<float> val;
+                    load(second, val);
+                    if(!val.empty())
+                    {
+                        t->setVars(static_cast<int>(val.size()), &val[0]);
+                    }
+                }
+                else if(key == "direction")
+                {
+                    TransformDirection val;
+                    load(second, val);
+                    t->setDirection(val);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
             }
-            else if(key == "cccid")
+        }
+        
+        inline void save(YAML::Emitter& out, ConstAllocationTransformRcPtr t)
+        {
+            out << YAML::VerbatimTag("AllocationTransform");
+            out << YAML::Flow << YAML::BeginMap;
+            
+            out << YAML::Key << "allocation";
+            out << YAML::Value << YAML::Flow;
+            save(out, t->getAllocation());
+            
+            if(t->getNumVars() > 0)
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setCCCId(stringval.c_str());
+                std::vector<float> vars(t->getNumVars());
+                t->getVars(&vars[0]);
+                out << YAML::Key << "vars";
+                out << YAML::Flow << YAML::Value << vars;
             }
-            else if(key == "interpolation")
+            
+            EmitBaseTransformKeyValues(out, t);
+            out << YAML::EndMap;
+        }
+        
+        // CDLTransform
+        
+        inline void load(const YAML::Node& node, CDLTransformRcPtr& t)
+        {
+            t = CDLTransform::Create();
+            
+            std::string key;
+            std::vector<float> floatvecval;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
             {
-                Interpolation val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<Interpolation>(val))
-                  t->setInterpolation(val);
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "slope")
+                {
+                    load(second, floatvecval);
+                    if(floatvecval.size() != 3)
+                    {
+                        std::ostringstream os;
+                        os << "CDLTransform parse error, 'slope' field must be 3 ";
+                        os << "floats. Found '" << floatvecval.size() << "'.";
+                        throw Exception(os.str().c_str());
+                    }
+                    t->setSlope(&floatvecval[0]);
+                }
+                else if(key == "offset")
+                {
+                    load(second, floatvecval);
+                    if(floatvecval.size() != 3)
+                    {
+                        std::ostringstream os;
+                        os << "CDLTransform parse error, 'offset' field must be 3 ";
+                        os << "floats. Found '" << floatvecval.size() << "'.";
+                        throw Exception(os.str().c_str());
+                    }
+                    t->setOffset(&floatvecval[0]);
+                }
+                else if(key == "power")
+                {
+                    load(second, floatvecval);
+                    if(floatvecval.size() != 3)
+                    {
+                        std::ostringstream os;
+                        os << "CDLTransform parse error, 'power' field must be 3 ";
+                        os << "floats. Found '" << floatvecval.size() << "'.";
+                        throw Exception(os.str().c_str());
+                    }
+                    t->setPower(&floatvecval[0]);
+                }
+                else if(key == "saturation" || key == "sat")
+                {
+                    float val = 0.0f;
+                    load(second, val);
+                    t->setSat(val);
+                }
+                else if(key == "direction")
+                {
+                    TransformDirection val;
+                    load(second, val);
+                    t->setDirection(val);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
             }
-            else if(key == "direction")
-            {
-                TransformDirection val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformDirection>(val))
-                  t->setDirection(val);
-            }
-            else
-            {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
-            }
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ConstFileTransformRcPtr t)
-    {
-        out << YAML::VerbatimTag("FileTransform");
-        out << YAML::Flow << YAML::BeginMap;
-        out << YAML::Key << "src" << YAML::Value << t->getSrc();
-        const char * cccid = t->getCCCId();
-        if(cccid && *cccid)
-        {
-            out << YAML::Key << "cccid" << YAML::Value << t->getCCCId();
-        }
-        out << YAML::Key << "interpolation";
-        out << YAML::Value << t->getInterpolation();
         
-        EmitBaseTransformKeyValues(out, t);
-        out << YAML::EndMap;
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, ColorSpaceTransformRcPtr& t)
-    {
-        t = ColorSpaceTransform::Create();
-        
-        std::string key, stringval;
-        
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        inline void save(YAML::Emitter& out, ConstCDLTransformRcPtr t)
         {
-            iter.first() >> key;
+            out << YAML::VerbatimTag("CDLTransform");
+            out << YAML::Flow << YAML::BeginMap;
             
-            if(key == "src")
+            std::vector<float> slope(3);
+            t->getSlope(&slope[0]);
+            if(!IsVecEqualToOne(&slope[0], 3))
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setSrc(stringval.c_str());
+                out << YAML::Key << "slope";
+                out << YAML::Value << YAML::Flow << slope;
             }
-            else if(key == "dst")
+            
+            std::vector<float> offset(3);
+            t->getOffset(&offset[0]);
+            if(!IsVecEqualToZero(&offset[0], 3))
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setDst(stringval.c_str());
+                out << YAML::Key << "offset";
+                out << YAML::Value << YAML::Flow << offset;
             }
-            else if(key == "direction")
+            
+            std::vector<float> power(3);
+            t->getPower(&power[0]);
+            if(!IsVecEqualToOne(&power[0], 3))
             {
-                TransformDirection val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformDirection>(val))
-                  t->setDirection(val);
+                out << YAML::Key << "power";
+                out << YAML::Value << YAML::Flow << power;
             }
-            else
+            
+            if(!IsScalarEqualToOne(t->getSat()))
             {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
+                out << YAML::Key << "sat" << YAML::Value << t->getSat();
             }
+            
+            EmitBaseTransformKeyValues(out, t);
+            out << YAML::EndMap;
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ConstColorSpaceTransformRcPtr t)
-    {
-        out << YAML::VerbatimTag("ColorSpaceTransform");
-        out << YAML::Flow << YAML::BeginMap;
-        out << YAML::Key << "src" << YAML::Value << t->getSrc();
-        out << YAML::Key << "dst" << YAML::Value << t->getDst();
-        EmitBaseTransformKeyValues(out, t);
-        out << YAML::EndMap;
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, LookTransformRcPtr& t)
-    {
-        t = LookTransform::Create();
         
-        std::string key, stringval;
+        // ColorSpaceTransform
         
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        inline void load(const YAML::Node& node, ColorSpaceTransformRcPtr& t)
         {
-            iter.first() >> key;
+            t = ColorSpaceTransform::Create();
             
-            if(key == "src")
+            std::string key, stringval;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setSrc(stringval.c_str());
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "src")
+                {
+                    load(second, stringval);
+                    t->setSrc(stringval.c_str());
+                }
+                else if(key == "dst")
+                {
+                    load(second, stringval);
+                    t->setDst(stringval.c_str());
+                }
+                else if(key == "direction")
+                {
+                    TransformDirection val;
+                    load(second, val);
+                    t->setDirection(val);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
             }
-            else if(key == "dst")
-            {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setDst(stringval.c_str());
-            }
-            else if(key == "looks")
-            {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setLooks(stringval.c_str());
-            }
-            else if(key == "direction")
-            {
-                TransformDirection val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformDirection>(val))
-                  t->setDirection(val);
-            }
-            else
-            {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
-            }
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ConstLookTransformRcPtr t)
-    {
-        out << YAML::VerbatimTag("LookTransform");
-        out << YAML::Flow << YAML::BeginMap;
-        out << YAML::Key << "src" << YAML::Value << t->getSrc();
-        out << YAML::Key << "dst" << YAML::Value << t->getDst();
-        out << YAML::Key << "looks" << YAML::Value << t->getLooks();
-        EmitBaseTransformKeyValues(out, t);
-        out << YAML::EndMap;
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, ExponentTransformRcPtr& t)
-    {
-        t = ExponentTransform::Create();
         
-        std::string key;
+        inline void save(YAML::Emitter& out, ConstColorSpaceTransformRcPtr t)
+        {
+            out << YAML::VerbatimTag("ColorSpaceTransform");
+            out << YAML::Flow << YAML::BeginMap;
+            out << YAML::Key << "src" << YAML::Value << t->getSrc();
+            out << YAML::Key << "dst" << YAML::Value << t->getDst();
+            EmitBaseTransformKeyValues(out, t);
+            out << YAML::EndMap;
+        }
         
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        // ExponentTransform
+        
+        inline void load(const YAML::Node& node, ExponentTransformRcPtr& t)
         {
-            iter.first() >> key;
+            t = ExponentTransform::Create();
             
-            if(key == "value")
+            std::string key;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
             {
-                std::vector<float> val;
-                if (iter.second().Type() != YAML::NodeType::Null)
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "value")
                 {
-                    iter.second() >> val;
+                    std::vector<float> val;
+                    load(second, val);
                     if(val.size() != 4)
                     {
                         std::ostringstream os;
@@ -668,96 +583,297 @@ OCIO_NAMESPACE_ENTER
                     }
                     t->setValue(&val[0]);
                 }
+                else if(key == "direction")
+                {
+                    TransformDirection val;
+                    load(second, val);
+                    t->setDirection(val);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
             }
-            else if(key == "direction")
+        }
+        
+        inline void save(YAML::Emitter& out, ConstExponentTransformRcPtr t)
+        {
+            out << YAML::VerbatimTag("ExponentTransform");
+            out << YAML::Flow << YAML::BeginMap;
+            
+            std::vector<float> value(4, 0.0);
+            t->getValue(&value[0]);
+            out << YAML::Key << "value";
+            out << YAML::Value << YAML::Flow << value;
+            EmitBaseTransformKeyValues(out, t);
+            out << YAML::EndMap;
+        }
+        
+        // FileTransform
+        
+        inline void load(const YAML::Node& node, FileTransformRcPtr& t)
+        {
+            t = FileTransform::Create();
+            
+            std::string key, stringval;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
             {
-                TransformDirection val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformDirection>(val))
-                  t->setDirection(val);
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "src")
+                {
+                    load(second, stringval);
+                    t->setSrc(stringval.c_str());
+                }
+                else if(key == "cccid")
+                {
+                    load(second, stringval);
+                    t->setCCCId(stringval.c_str());
+                }
+                else if(key == "interpolation")
+                {
+                    Interpolation val;
+                    load(second, val);
+                    t->setInterpolation(val);
+                }
+                else if(key == "direction")
+                {
+                    TransformDirection val;
+                    load(second, val);
+                    t->setDirection(val);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
             }
-            else
+        }
+        
+        inline void save(YAML::Emitter& out, ConstFileTransformRcPtr t)
+        {
+            out << YAML::VerbatimTag("FileTransform");
+            out << YAML::Flow << YAML::BeginMap;
+            out << YAML::Key << "src" << YAML::Value << t->getSrc();
+            const char * cccid = t->getCCCId();
+            if(cccid && *cccid)
             {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
+                out << YAML::Key << "cccid" << YAML::Value << t->getCCCId();
             }
+            out << YAML::Key << "interpolation";
+            out << YAML::Value;
+            save(out, t->getInterpolation());
+            
+            EmitBaseTransformKeyValues(out, t);
+            out << YAML::EndMap;
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ConstExponentTransformRcPtr t)
-    {
-        out << YAML::VerbatimTag("ExponentTransform");
-        out << YAML::Flow << YAML::BeginMap;
         
-        std::vector<float> value(4, 0.0);
-        t->getValue(&value[0]);
-        out << YAML::Key << "value";
-        out << YAML::Value << YAML::Flow << value;
-        EmitBaseTransformKeyValues(out, t);
-        out << YAML::EndMap;
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, LogTransformRcPtr& t)
-    {
-        t = LogTransform::Create();
+        // GroupTransform
         
-        std::string key;
+        void load(const YAML::Node& node, TransformRcPtr& t);
+        void save(YAML::Emitter& out, ConstTransformRcPtr t);
         
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        inline void load(const YAML::Node& node, GroupTransformRcPtr& t)
         {
-            iter.first() >> key;
+            t = GroupTransform::Create();
             
-            if(key == "base")
+            std::string key;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
             {
-                float val = 0.0f;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<float>(val))
-                  t->setBase(val);
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "children")
+                {
+                    for(unsigned i = 0; i < second.size(); ++i)
+                    {
+                        TransformRcPtr childTransform;
+                        load(second[i], childTransform);
+                        
+                        // TODO: consider the forwards-compatibility implication of
+                        // throwing an exception.  Should this be a warning, instead?
+                        if(!childTransform)
+                        {
+                            throw Exception("Child transform could not be parsed.");
+                        }
+                        
+                        t->push_back(childTransform);
+                    }
+                }
+                else if(key == "direction")
+                {
+                    TransformDirection val;
+                    load(second, val);
+                    t->setDirection(val);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
             }
-            else if(key == "direction")
+        }
+        
+        inline void save(YAML::Emitter& out, ConstGroupTransformRcPtr t)
+        {
+            out << YAML::VerbatimTag("GroupTransform");
+            out << YAML::BeginMap;
+            EmitBaseTransformKeyValues(out, t);
+            
+            out << YAML::Key << "children";
+            out << YAML::Value;
+            
+            out << YAML::BeginSeq;
+            for(int i = 0; i < t->size(); ++i)
             {
-                TransformDirection val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformDirection>(val))
-                  t->setDirection(val);
+                save(out, t->getTransform(i));
             }
-            else
+            out << YAML::EndSeq;
+            
+            out << YAML::EndMap;
+        }
+        
+        // LogTransform
+        
+        inline void load(const YAML::Node& node, LogTransformRcPtr& t)
+        {
+            t = LogTransform::Create();
+            
+            std::string key;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
             {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "base")
+                {
+                    float val = 0.0f;
+                    load(second, val);
+                    t->setBase(val);
+                }
+                else if(key == "direction")
+                {
+                    TransformDirection val;
+                    load(second, val);
+                    t->setDirection(val);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
             }
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ConstLogTransformRcPtr t)
-    {
-        out << YAML::VerbatimTag("LogTransform");
-        out << YAML::Flow << YAML::BeginMap;
-        out << YAML::Key << "base" << YAML::Value << t->getBase();
-        EmitBaseTransformKeyValues(out, t);
-        out << YAML::EndMap;
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, MatrixTransformRcPtr& t)
-    {
-        t = MatrixTransform::Create();
         
-        std::string key;
+        inline void save(YAML::Emitter& out, ConstLogTransformRcPtr t)
+        {
+            out << YAML::VerbatimTag("LogTransform");
+            out << YAML::Flow << YAML::BeginMap;
+            out << YAML::Key << "base" << YAML::Value << t->getBase();
+            EmitBaseTransformKeyValues(out, t);
+            out << YAML::EndMap;
+        }
         
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        // LookTransform
+        
+        inline void load(const YAML::Node& node, LookTransformRcPtr& t)
         {
-            iter.first() >> key;
+            t = LookTransform::Create();
             
-            if(key == "matrix")
+            std::string key, stringval;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
             {
-                std::vector<float> val;
-                if (iter.second().Type() != YAML::NodeType::Null)
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "src")
                 {
-                    iter.second() >> val;
+                    load(second, stringval);
+                    t->setSrc(stringval.c_str());
+                }
+                else if(key == "dst")
+                {
+                    load(second, stringval);
+                    t->setDst(stringval.c_str());
+                }
+                else if(key == "looks")
+                {
+                    load(second, stringval);
+                    t->setLooks(stringval.c_str());
+                }
+                else if(key == "direction")
+                {
+                    TransformDirection val;
+                    load(second, val);
+                    t->setDirection(val);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
+            }
+        }
+        
+        inline void save(YAML::Emitter& out, ConstLookTransformRcPtr t)
+        {
+            out << YAML::VerbatimTag("LookTransform");
+            out << YAML::Flow << YAML::BeginMap;
+            out << YAML::Key << "src" << YAML::Value << t->getSrc();
+            out << YAML::Key << "dst" << YAML::Value << t->getDst();
+            out << YAML::Key << "looks" << YAML::Value << t->getLooks();
+            EmitBaseTransformKeyValues(out, t);
+            out << YAML::EndMap;
+        }
+        
+        // MatrixTransform
+        
+        inline void load(const YAML::Node& node, MatrixTransformRcPtr& t)
+        {
+            t = MatrixTransform::Create();
+            
+            std::string key;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
+            {
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "matrix")
+                {
+                    std::vector<float> val;
+                    load(second, val);
                     if(val.size() != 16)
                     {
                         std::ostringstream os;
@@ -767,13 +883,10 @@ OCIO_NAMESPACE_ENTER
                     }
                     t->setMatrix(&val[0]);
                 }
-            }
-            else if(key == "offset")
-            {
-                std::vector<float> val;
-                if (iter.second().Type() != YAML::NodeType::Null)
+                else if(key == "offset")
                 {
-                    iter.second() >> val;
+                    std::vector<float> val;
+                    load(second, val);
                     if(val.size() != 4)
                     {
                         std::ostringstream os;
@@ -783,435 +896,921 @@ OCIO_NAMESPACE_ENTER
                     }
                     t->setOffset(&val[0]);
                 }
+                else if(key == "direction")
+                {
+                    TransformDirection val;
+                    load(second, val);
+                    t->setDirection(val);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
             }
-            else if(key == "direction")
+        }
+        
+        inline void save(YAML::Emitter& out, ConstMatrixTransformRcPtr t)
+        {
+            out << YAML::VerbatimTag("MatrixTransform");
+            out << YAML::Flow << YAML::BeginMap;
+            
+            std::vector<float> matrix(16, 0.0);
+            t->getMatrix(&matrix[0]);
+            if(!IsM44Identity(&matrix[0]))
             {
-                TransformDirection val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformDirection>(val))
-                  t->setDirection(val);
+                out << YAML::Key << "matrix";
+                out << YAML::Value << YAML::Flow << matrix;
             }
-            else
+            
+            std::vector<float> offset(4, 0.0);
+            t->getOffset(&offset[0]);
+            if(!IsVecEqualToZero(&offset[0],4))
             {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
+                out << YAML::Key << "offset";
+                out << YAML::Value << YAML::Flow << offset;
             }
+            
+            EmitBaseTransformKeyValues(out, t);
+            out << YAML::EndMap;
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ConstMatrixTransformRcPtr t)
-    {
-        out << YAML::VerbatimTag("MatrixTransform");
-        out << YAML::Flow << YAML::BeginMap;
         
-        std::vector<float> matrix(16, 0.0);
-        t->getMatrix(&matrix[0]);
-        if(!IsM44Identity(&matrix[0]))
-        {
-            out << YAML::Key << "matrix";
-            out << YAML::Value << YAML::Flow << matrix;
-        }
+        // TruelightTransform
         
-        std::vector<float> offset(4, 0.0);
-        t->getOffset(&offset[0]);
-        if(!IsVecEqualToZero(&offset[0],4))
+        inline void load(const YAML::Node& node, TruelightTransformRcPtr& t)
         {
-            out << YAML::Key << "offset";
-            out << YAML::Value << YAML::Flow << offset;
+            t = TruelightTransform::Create();
+            
+            std::string key, stringval;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
+            {
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "config_root")
+                {
+                    load(second, stringval);
+                    t->setConfigRoot(stringval.c_str());
+                }
+                else if(key == "profile")
+                {
+                    load(second, stringval);
+                    t->setProfile(stringval.c_str());
+                }
+                else if(key == "camera")
+                {
+                    load(second, stringval);
+                    t->setCamera(stringval.c_str());
+                }
+                else if(key == "input_display")
+                {
+                    load(second, stringval);
+                    t->setInputDisplay(stringval.c_str());
+                }
+                else if(key == "recorder")
+                {
+                    load(second, stringval);
+                    t->setRecorder(stringval.c_str());
+                }
+                else if(key == "print")
+                {
+                    load(second, stringval);
+                    t->setPrint(stringval.c_str());
+                }
+                else if(key == "lamp")
+                {
+                    load(second, stringval);
+                    t->setLamp(stringval.c_str());
+                }
+                else if(key == "output_camera")
+                {
+                    load(second, stringval);
+                    t->setOutputCamera(stringval.c_str());
+                }
+                else if(key == "display")
+                {
+                    load(second, stringval);
+                    t->setDisplay(stringval.c_str());
+                }
+                else if(key == "cube_input")
+                {
+                    load(second, stringval);
+                     t->setCubeInput(stringval.c_str());
+                }
+                else if(key == "direction")
+                {
+                    TransformDirection val;
+                    load(second, val);
+                    t->setDirection(val);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
+            }
         }
         
-        EmitBaseTransformKeyValues(out, t);
-        out << YAML::EndMap;
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, CDLTransformRcPtr& t)
-    {
-        t = CDLTransform::Create();
-        
-        std::string key;
-        std::vector<float> floatvecval;
-        
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        inline void save(YAML::Emitter& out, ConstTruelightTransformRcPtr t)
         {
-            iter.first() >> key;
             
-            if(key == "slope")
+            out << YAML::VerbatimTag("TruelightTransform");
+            out << YAML::Flow << YAML::BeginMap;
+            if(strcmp(t->getConfigRoot(), "") != 0)
             {
-                if (iter.second().Type() != YAML::NodeType::Null)
-                {
-                    iter.second() >> floatvecval;
-                    if(floatvecval.size() != 3)
-                    {
-                        std::ostringstream os;
-                        os << "CDLTransform parse error, 'slope' field must be 3 ";
-                        os << "floats. Found '" << floatvecval.size() << "'.";
-                        throw Exception(os.str().c_str());
-                    }
-                    t->setSlope(&floatvecval[0]);
-                }
+                out << YAML::Key << "config_root";
+                out << YAML::Value << YAML::Flow << t->getConfigRoot();
             }
-            else if(key == "offset")
+            if(strcmp(t->getProfile(), "") != 0)
             {
-                if (iter.second().Type() != YAML::NodeType::Null)
-                {
-                    iter.second() >> floatvecval;
-                    if(floatvecval.size() != 3)
-                    {
-                        std::ostringstream os;
-                        os << "CDLTransform parse error, 'offset' field must be 3 ";
-                        os << "floats. Found '" << floatvecval.size() << "'.";
-                        throw Exception(os.str().c_str());
-                    }
-                    t->setOffset(&floatvecval[0]);
-                }
+                out << YAML::Key << "profile";
+                out << YAML::Value << YAML::Flow << t->getProfile();
             }
-            else if(key == "power")
+            if(strcmp(t->getCamera(), "") != 0)
             {
-                if (iter.second().Type() != YAML::NodeType::Null)
-                {
-                    iter.second() >> floatvecval;
-                    if(floatvecval.size() != 3)
-                    {
-                        std::ostringstream os;
-                        os << "CDLTransform parse error, 'power' field must be 3 ";
-                        os << "floats. Found '" << floatvecval.size() << "'.";
-                        throw Exception(os.str().c_str());
-                    }
-                    t->setPower(&floatvecval[0]);
-                }
+                out << YAML::Key << "camera";
+                out << YAML::Value << YAML::Flow << t->getCamera();
             }
-            else if(key == "saturation" || key == "sat")
+            if(strcmp(t->getInputDisplay(), "") != 0)
             {
-                float val = 0.0f;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<float>(val))
-                  t->setSat(val);
+                out << YAML::Key << "input_display";
+                out << YAML::Value << YAML::Flow << t->getInputDisplay();
             }
-            else if(key == "direction")
+            if(strcmp(t->getRecorder(), "") != 0)
             {
-                TransformDirection val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformDirection>(val))
-                  t->setDirection(val);
+                out << YAML::Key << "recorder";
+                out << YAML::Value << YAML::Flow << t->getRecorder();
             }
-            else
+            if(strcmp(t->getPrint(), "") != 0)
             {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
+                out << YAML::Key << "print";
+                out << YAML::Value << YAML::Flow << t->getPrint();
             }
+            if(strcmp(t->getLamp(), "") != 0)
+            {
+                out << YAML::Key << "lamp";
+                out << YAML::Value << YAML::Flow << t->getLamp();
+            }
+            if(strcmp(t->getOutputCamera(), "") != 0)
+            {
+                out << YAML::Key << "output_camera";
+                out << YAML::Value << YAML::Flow << t->getOutputCamera();
+            }
+            if(strcmp(t->getDisplay(), "") != 0)
+            {
+                out << YAML::Key << "display";
+                out << YAML::Value << YAML::Flow << t->getDisplay();
+            }
+            if(strcmp(t->getCubeInput(), "") != 0)
+            {
+                out << YAML::Key << "cube_input";
+                out << YAML::Value << YAML::Flow << t->getCubeInput();
+            }
+            
+            EmitBaseTransformKeyValues(out, t);
+            
+            out << YAML::EndMap;
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ConstCDLTransformRcPtr t)
-    {
-        out << YAML::VerbatimTag("CDLTransform");
-        out << YAML::Flow << YAML::BeginMap;
         
-        std::vector<float> slope(3);
-        t->getSlope(&slope[0]);
-        if(!IsVecEqualToOne(&slope[0], 3))
-        {
-            out << YAML::Key << "slope";
-            out << YAML::Value << YAML::Flow << slope;
-        }
+        // Transform
         
-        std::vector<float> offset(3);
-        t->getOffset(&offset[0]);
-        if(!IsVecEqualToZero(&offset[0], 3))
+        void load(const YAML::Node& node, TransformRcPtr& t)
         {
-            out << YAML::Key << "offset";
-            out << YAML::Value << YAML::Flow << offset;
+            if(node.Type() != YAML::NodeType::Map)
+            {
+                std::ostringstream os;
+                os << "Unsupported Transform type encountered: (" << node.Type() << ") in OCIO profile. ";
+                os << "Only Mapping types supported.";
+                throw Exception(os.str().c_str());
+            }
+            
+            std::string type = node.Tag();
+            
+            if(type == "AllocationTransform") {
+                AllocationTransformRcPtr temp;
+                load(node, temp);
+                t = temp;
+            }
+            else if(type == "CDLTransform") {
+                CDLTransformRcPtr temp;
+                load(node, temp);
+                t = temp;
+            }
+            else if(type == "ColorSpaceTransform")  {
+                ColorSpaceTransformRcPtr temp;
+                load(node, temp);
+                t = temp;
+            }
+            // TODO: DisplayTransform
+            else if(type == "ExponentTransform")  {
+                ExponentTransformRcPtr temp;
+                load(node, temp);
+                t = temp;
+            }
+            else if(type == "FileTransform")  {
+                FileTransformRcPtr temp;
+                load(node, temp);
+                t = temp;
+            }
+            else if(type == "GroupTransform") {
+                GroupTransformRcPtr temp;
+                load(node, temp);
+                t = temp;
+            }
+            else if(type == "LogTransform") {
+                LogTransformRcPtr temp;
+                load(node, temp);
+                t = temp;
+            }
+            else if(type == "LookTransform") {
+                LookTransformRcPtr temp;
+                load(node, temp);
+                t = temp;
+            }
+            else if(type == "MatrixTransform")  {
+                MatrixTransformRcPtr temp;
+                load(node, temp);
+                t = temp;
+            }
+            else if(type == "TruelightTransform")  {
+                TruelightTransformRcPtr temp;
+                load(node, temp);
+                t = temp;
+            }
+            else
+            {
+                // TODO: add a new empty (better name?) aka passthru Transform()
+                // which does nothing. This is so upsupported !<tag> types don't
+                // throw an exception. Alternativly this could be caught in the
+                // GroupTransformRcPtr >> operator with some type of
+                // supported_tag() method
+                
+                // TODO: consider the forwards-compatibility implication of
+                // throwing an exception.  Should this be a warning, instead?
+                
+                //  t = EmptyTransformRcPtr(new EmptyTransform(), &deleter);
+                std::ostringstream os;
+                os << "Unsupported transform type !<" << type << "> in OCIO profile. ";
+                throw Exception(os.str().c_str());
+            }
         }
         
-        std::vector<float> power(3);
-        t->getPower(&power[0]);
-        if(!IsVecEqualToOne(&power[0], 3))
+        void save(YAML::Emitter& out, ConstTransformRcPtr t)
         {
-            out << YAML::Key << "power";
-            out << YAML::Value << YAML::Flow << power;
+            if(ConstAllocationTransformRcPtr Allocation_tran = \
+                DynamicPtrCast<const AllocationTransform>(t))
+                save(out, Allocation_tran);
+            else if(ConstCDLTransformRcPtr CDL_tran = \
+                DynamicPtrCast<const CDLTransform>(t))
+                save(out, CDL_tran);
+            else if(ConstColorSpaceTransformRcPtr ColorSpace_tran = \
+                DynamicPtrCast<const ColorSpaceTransform>(t))
+                save(out, ColorSpace_tran);
+            else if(ConstExponentTransformRcPtr Exponent_tran = \
+                DynamicPtrCast<const ExponentTransform>(t))
+                save(out, Exponent_tran);
+            else if(ConstFileTransformRcPtr File_tran = \
+                DynamicPtrCast<const FileTransform>(t))
+                save(out, File_tran);
+            else if(ConstGroupTransformRcPtr Group_tran = \
+                DynamicPtrCast<const GroupTransform>(t))
+                save(out, Group_tran);
+            else if(ConstLogTransformRcPtr Log_tran = \
+                DynamicPtrCast<const LogTransform>(t))
+                save(out, Log_tran);
+            else if(ConstLookTransformRcPtr Look_tran = \
+                DynamicPtrCast<const LookTransform>(t))
+                save(out, Look_tran);
+            else if(ConstMatrixTransformRcPtr Matrix_tran = \
+                DynamicPtrCast<const MatrixTransform>(t))
+                save(out, Matrix_tran);
+            else if(ConstTruelightTransformRcPtr Truelight_tran = \
+                DynamicPtrCast<const TruelightTransform>(t))
+                save(out, Truelight_tran);
+            else
+                throw Exception("Unsupported Transform() type for serialization.");
         }
         
-        if(!IsScalarEqualToOne(t->getSat()))
+        // ColorSpace
+        
+        inline void load(const YAML::Node& node, ColorSpaceRcPtr& cs)
         {
-            out << YAML::Key << "sat" << YAML::Value << t->getSat();
+            if(node.Tag() != "ColorSpace")
+                return; // not a !<ColorSpace> tag
+            
+            std::string key, stringval;
+            bool boolval;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
+            {
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "name")
+                {
+                    load(second, stringval);
+                    cs->setName(stringval.c_str());
+                }
+                else if(key == "description")
+                {
+                    load(second, stringval);
+                    cs->setDescription(stringval.c_str());
+                }
+                else if(key == "family")
+                {
+                    load(second, stringval);
+                    cs->setFamily(stringval.c_str());
+                }
+                else if(key == "equalitygroup")
+                {
+                    load(second, stringval);
+                    cs->setEqualityGroup(stringval.c_str());
+                }
+                else if(key == "bitdepth")
+                {
+                    BitDepth ret;
+                    load(second, ret);
+                    cs->setBitDepth(ret);
+                }
+                else if(key == "isdata")
+                {
+                    load(second, boolval);
+                    cs->setIsData(boolval);
+                }
+                else if(key == "allocation")
+                {
+                    Allocation val;
+                    load(second, val);
+                    cs->setAllocation(val);
+                }
+                else if(key == "allocationvars")
+                {
+                    std::vector<float> val;
+                    load(second, val);
+                    if(!val.empty())
+                        cs->setAllocationVars(static_cast<int>(val.size()), &val[0]);
+                }
+                else if(key == "to_reference")
+                {
+                    TransformRcPtr val;
+                    load(second, val);
+                    cs->setTransform(val, COLORSPACE_DIR_TO_REFERENCE);
+                }
+                else if(key == "from_reference")
+                {
+                    TransformRcPtr val;
+                    load(second, val);
+                    cs->setTransform(val, COLORSPACE_DIR_FROM_REFERENCE);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
+            }
         }
         
-        EmitBaseTransformKeyValues(out, t);
-        out << YAML::EndMap;
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, AllocationTransformRcPtr& t)
-    {
-        t = AllocationTransform::Create();
-        
-        std::string key;
-        
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        inline void save(YAML::Emitter& out, ConstColorSpaceRcPtr cs)
         {
-            iter.first() >> key;
+            out << YAML::VerbatimTag("ColorSpace");
+            out << YAML::BeginMap;
             
-            if(key == "allocation")
+            out << YAML::Key << "name" << YAML::Value << cs->getName();
+            out << YAML::Key << "family" << YAML::Value << cs->getFamily();
+            out << YAML::Key << "equalitygroup" << YAML::Value << cs->getEqualityGroup();
+            out << YAML::Key << "bitdepth" << YAML::Value;
+            save(out, cs->getBitDepth());
+            if(cs->getDescription() != NULL && strlen(cs->getDescription()) > 0)
             {
-                Allocation val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<Allocation>(val))
-                  t->setAllocation(val);
+                out << YAML::Key << "description";
+                out << YAML::Value << YAML::Literal << cs->getDescription();
             }
-            else if(key == "vars")
+            out << YAML::Key << "isdata" << YAML::Value << cs->isData();
+            
+            out << YAML::Key << "allocation" << YAML::Value;
+            save(out, cs->getAllocation());
+            if(cs->getAllocationNumVars() > 0)
             {
-                std::vector<float> val;
-                if (iter.second().Type() != YAML::NodeType::Null)
-                {
-                    iter.second() >> val;
-                    if(!val.empty())
-                    {
-                        t->setVars(static_cast<int>(val.size()), &val[0]);
-                    }
-                }
+                std::vector<float> allocationvars(cs->getAllocationNumVars());
+                cs->getAllocationVars(&allocationvars[0]);
+                out << YAML::Key << "allocationvars";
+                out << YAML::Flow << YAML::Value << allocationvars;
             }
-            else if(key == "direction")
+            
+            ConstTransformRcPtr toref = \
+                cs->getTransform(COLORSPACE_DIR_TO_REFERENCE);
+            if(toref)
             {
-                TransformDirection val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformDirection>(val))
-                  t->setDirection(val);
+                out << YAML::Key << "to_reference" << YAML::Value;
+                save(out, toref);
             }
-            else
+            
+            ConstTransformRcPtr fromref = \
+                cs->getTransform(COLORSPACE_DIR_FROM_REFERENCE);
+            if(fromref)
             {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
+                out << YAML::Key << "from_reference" << YAML::Value;
+                save(out, fromref);
             }
+            
+            out << YAML::EndMap;
+            out << YAML::Newline;
         }
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ConstAllocationTransformRcPtr t)
-    {
-        out << YAML::VerbatimTag("AllocationTransform");
-        out << YAML::Flow << YAML::BeginMap;
         
-        out << YAML::Key << "allocation";
-        out << YAML::Value << YAML::Flow << t->getAllocation();
+        // Look
         
-        if(t->getNumVars() > 0)
+        inline void load(const YAML::Node& node, LookRcPtr& look)
         {
-            std::vector<float> vars(t->getNumVars());
-            t->getVars(&vars[0]);
-            out << YAML::Key << "vars";
-            out << YAML::Flow << YAML::Value << vars;
+            if(node.Tag() != "Look")
+                return;
+            
+            std::string key, stringval;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
+            {
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "name")
+                {
+                    load(second, stringval);
+                    look->setName(stringval.c_str());
+                }
+                else if(key == "process_space")
+                {
+                    load(second, stringval);
+                    look->setProcessSpace(stringval.c_str());
+                }
+                else if(key == "transform")
+                {
+                    TransformRcPtr val;
+                    load(second, val);
+                    look->setTransform(val);
+                }
+                else if(key == "inverse_transform")
+                {
+                    TransformRcPtr val;
+                    load(second, val);
+                    look->setInverseTransform(val);
+                }
+                else
+                {
+                    LogUnknownKeyWarning(node.Tag(), first);
+                }
+            }
         }
         
-        EmitBaseTransformKeyValues(out, t);
-        out << YAML::EndMap;
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, TruelightTransformRcPtr& t)
-    {
-        t = TruelightTransform::Create();
-        
-        std::string key, stringval;
-        
-        for (YAML::Iterator iter = node.begin();
-             iter != node.end();
-             ++iter)
+        inline void save(YAML::Emitter& out, ConstLookRcPtr look)
         {
-            iter.first() >> key;
+            out << YAML::VerbatimTag("Look");
+            out << YAML::BeginMap;
+            out << YAML::Key << "name" << YAML::Value << look->getName();
+            out << YAML::Key << "process_space" << YAML::Value << look->getProcessSpace();
             
-            if(key == "config_root")
+            if(look->getTransform())
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setConfigRoot(stringval.c_str());
+                out << YAML::Key << "transform";
+                out << YAML::Value;
+                save(out, look->getTransform());
             }
-            else if(key == "profile")
+            
+            if(look->getInverseTransform())
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setProfile(stringval.c_str());
+                out << YAML::Key << "inverse_transform";
+                out << YAML::Value;
+                save(out, look->getInverseTransform());
             }
-            else if(key == "camera")
+            
+            out << YAML::EndMap;
+            out << YAML::Newline;
+        }
+        
+        // Config
+        
+        inline void load(const YAML::Node& node, ConfigRcPtr& c, const char* filename)
+        {
+            
+            // check profile version
+            int profile_version = 0;
+#ifdef OLDYAML
+            if(node.FindValue("ocio_profile_version") == NULL)
+#else
+            if(node["ocio_profile_version"] == NULL)
+#endif
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setCamera(stringval.c_str());
+                std::ostringstream os;
+                os << "The specified file ";
+                os << "does not appear to be an OCIO configuration.";
+                throw Exception (os.str().c_str());
             }
-            else if(key == "input_display")
+            
+            load(node["ocio_profile_version"], profile_version);
+            if(profile_version > 1)
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setInputDisplay(stringval.c_str());
+                std::ostringstream os;
+                os << "This .ocio config ";
+                if(filename && *filename)
+                {
+                    os << " '" << filename << "' ";
+                }
+                os << "is version " << profile_version << ". ";
+                os << "This version of the OpenColorIO library (" << OCIO_VERSION ") ";
+                os << "is not known to be able to load this profile. ";
+                os << "An attempt will be made, but there are no guarantees that the ";
+                os << "results will be accurate. Continue at your own risk.";
+                LogWarning(os.str());
             }
-            else if(key == "recorder")
+            
+            std::string key, stringval;
+            bool boolval = false;
+            EnvironmentMode mode = ENV_ENVIRONMENT_LOAD_ALL;
+            
+            for (Iterator iter = node.begin();
+                 iter != node.end();
+                 ++iter)
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setRecorder(stringval.c_str());
+                const YAML::Node& first = get_first(iter);
+                const YAML::Node& second = get_second(iter);
+                
+                load(first, key);
+                
+                if (second.Type() == YAML::NodeType::Null) continue;
+                
+                if(key == "ocio_profile_version") { } // Already handled above.
+                else if(key == "environment")
+                {
+                    mode = ENV_ENVIRONMENT_LOAD_PREDEFINED;
+                    if(second.Type() != YAML::NodeType::Map)
+                    {
+                        std::ostringstream os;
+                        os << "'environment' field needs to be a (name: key) map.";
+                        throw Exception(os.str().c_str());
+                    }
+                    for (Iterator it = second.begin();
+                         it != second.end();
+                         ++it)
+                    {
+                        std::string k, v;
+                        load(get_first(it), k);
+                        load(get_second(it), v);
+                        c->addEnvironmentVar(k.c_str(), v.c_str());
+                    }
+                }
+                else if(key == "search_path" || key == "resource_path")
+                {
+                    load(second, stringval);
+                    c->setSearchPath(stringval.c_str());
+                }
+                else if(key == "strictparsing")
+                {
+                    load(second, boolval);
+                    c->setStrictParsingEnabled(boolval);
+                }
+                else if(key == "description")
+                {
+                    load(second, stringval);
+                    c->setDescription(stringval.c_str());
+                }
+                else if(key == "luma")
+                {
+                    std::vector<float> val;
+                    load(second, val);
+                    if(val.size() != 3)
+                    {
+                        std::ostringstream os;
+                        os << "'luma' field must be 3 ";
+                        os << "floats. Found '" << val.size() << "'.";
+                        throw Exception(os.str().c_str());
+                    }
+                    c->setDefaultLumaCoefs(&val[0]);
+                }
+                else if(key == "roles")
+                {
+                    if(second.Type() != YAML::NodeType::Map)
+                    {
+                        std::ostringstream os;
+                        os << "'roles' field needs to be a (name: key) map.";
+                        throw Exception(os.str().c_str());
+                    }
+                    for (Iterator it = second.begin();
+                         it != second.end();
+                         ++it)
+                    {
+                        std::string k, v;
+                        load(get_first(it), k);
+                        load(get_second(it), v);
+                        c->setRole(k.c_str(), v.c_str());
+                    }
+                }
+                else if(key == "displays")
+                {
+                    if(second.Type() != YAML::NodeType::Map)
+                    {
+                        std::ostringstream os;
+                        os << "'displays' field needs to be a (name: key) map.";
+                        throw Exception(os.str().c_str());
+                    }
+                    for (Iterator it = second.begin();
+                         it != second.end();
+                         ++it)
+                    {
+                        std::string display;
+                        load(get_first(it), display);
+                        const YAML::Node& dsecond = get_second(it);
+                        for(unsigned i = 0; i < dsecond.size(); ++i)
+                        {
+                            View view;
+                            load(dsecond[i], view);
+                            c->addDisplay(display.c_str(), view.name.c_str(),
+                                          view.colorspace.c_str(), view.looks.c_str());
+                        }
+                    }
+                }
+                else if(key == "active_displays")
+                {
+                    std::vector<std::string> display;
+                    load(second, display);
+                    const char* displays = JoinStringEnvStyle(display).c_str();
+                    c->setActiveDisplays(displays);
+                }
+                else if(key == "active_views")
+                {
+                    std::vector<std::string> view;
+                    load(second, view);
+                    const char* views = JoinStringEnvStyle(view).c_str();
+                    c->setActiveViews(views);
+                }
+                else if(key == "colorspaces")
+                {
+                    if(second.Type() != YAML::NodeType::Sequence)
+                    {
+                        std::ostringstream os;
+                        os << "'colorspaces' field needs to be a (- !<ColorSpace>) list.";
+                        throw Exception(os.str().c_str());
+                    }
+                    for(unsigned i = 0; i < second.size(); ++i)
+                    {
+                        if(second[i].Tag() == "ColorSpace")
+                        {
+                            ColorSpaceRcPtr cs = ColorSpace::Create();
+                            load(second[i], cs);
+                            for(int ii = 0; ii < c->getNumColorSpaces(); ++ii)
+                            {
+                                if(strcmp(c->getColorSpaceNameByIndex(ii), cs->getName()) == 0)
+                                {
+                                    std::ostringstream os;
+                                    os << "Colorspace with name '" << cs->getName() << "' already defined.";
+                                    throw Exception(os.str().c_str());
+                                }
+                            }
+                            c->addColorSpace(cs);
+                        }
+                        else
+                        {
+                            std::ostringstream os;
+                            os << "Unknown element found in colorspaces:";
+                            os << second[i].Tag() << ". Only ColorSpace(s)";
+                            os << " currently handled.";
+                            LogWarning(os.str());
+                        }
+                    }
+                }
+                else if(key == "looks")
+                {
+                    if(second.Type() != YAML::NodeType::Sequence)
+                    {
+                        std::ostringstream os;
+                        os << "'looks' field needs to be a (- !<Look>) list.";
+                        throw Exception(os.str().c_str());
+                    }
+                    
+                    for(unsigned i = 0; i < second.size(); ++i)
+                    {
+                        if(second[i].Tag() == "Look")
+                        {
+                            LookRcPtr look = Look::Create();
+                            load(second[i], look);
+                            c->addLook(look);
+                        }
+                        else
+                        {
+                            std::ostringstream os;
+                            os << "Unknown element found in looks:";
+                            os << second[i].Tag() << ". Only Look(s)";
+                            os << " currently handled.";
+                            LogWarning(os.str());
+                        }
+                    }
+                }
+                else
+                {
+                    LogUnknownKeyWarning("profile", first);
+                }
             }
-            else if(key == "print")
+            
+            if(filename)
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setPrint(stringval.c_str());
+                std::string realfilename = pystring::os::path::abspath(filename);
+                std::string configrootdir = pystring::os::path::dirname(realfilename);
+                c->setWorkingDir(configrootdir.c_str());
             }
-            else if(key == "lamp")
+            
+            c->setEnvironmentMode(mode);
+            c->loadEnvironment();
+            
+            if(mode == ENV_ENVIRONMENT_LOAD_ALL)
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setLamp(stringval.c_str());
+                std::ostringstream os;
+                os << "This .ocio config ";
+                if(filename && *filename)
+                {
+                    os << " '" << filename << "' ";
+                }
+                os << "has no environment section defined. The default behaviour is to ";
+                os << "load all environment variables (" << c->getNumEnvironmentVars() << ")";
+                os << ", which reduces the efficiency of OCIO's caching. Considering ";
+                os << "predefining the environment variables used.";
+                LogDebug(os.str());
             }
-            else if(key == "output_camera")
+            
+        }
+        
+        inline void save(YAML::Emitter& out, const Config* c)
+        {
+            out << YAML::Block;
+            out << YAML::BeginMap;
+            out << YAML::Key << "ocio_profile_version" << YAML::Value << 1;
+            out << YAML::Newline;
+#ifndef OLDYAML
+            out << YAML::Newline;
+#endif
+            
+            if(c->getNumEnvironmentVars() > 0)
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setOutputCamera(stringval.c_str());
+                out << YAML::Key << "environment";
+                out << YAML::Value << YAML::BeginMap;
+                for(unsigned i = 0; i < c->getNumEnvironmentVars(); ++i)
+                {   
+                    const char* name = c->getEnvironmentVarNameByIndex(i);
+                    out << YAML::Key << name;
+                    out << YAML::Value << c->getEnvironmentVarDefault(name);
+                }
+                out << YAML::EndMap;
+                out << YAML::Newline;
             }
-            else if(key == "display")
+            out << YAML::Key << "search_path" << YAML::Value << c->getSearchPath();
+            out << YAML::Key << "strictparsing" << YAML::Value << c->isStrictParsingEnabled();
+            
+            std::vector<float> luma(3, 0.f);
+            c->getDefaultLumaCoefs(&luma[0]);
+            out << YAML::Key << "luma" << YAML::Value << YAML::Flow << luma;
+            
+            if(c->getDescription() != NULL && strlen(c->getDescription()) > 0)
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setDisplay(stringval.c_str());
+                out << YAML::Newline;
+                out << YAML::Key << "description";
+                out << YAML::Value << c->getDescription();
+                out << YAML::Newline;
             }
-            else if(key == "cube_input")
+            
+            // Roles
+            out << YAML::Newline;
+#ifndef OLDYAML
+            out << YAML::Newline;
+#endif
+            out << YAML::Key << "roles";
+            out << YAML::Value << YAML::BeginMap;
+            for(unsigned i = 0; i < c->getNumRoles(); ++i)
             {
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<std::string>(stringval))
-                  t->setCubeInput(stringval.c_str());
+                const char* role = c->getRoleName(i);
+                out << YAML::Key << role;
+                out << YAML::Value << c->getColorSpace(role)->getName();
             }
-            else if(key == "direction")
+            out << YAML::EndMap;
+#ifndef OLDYAML
+            out << YAML::Newline;
+#endif
+            
+            // Displays
+            out << YAML::Newline;
+            out << YAML::Key << "displays";
+            out << YAML::Value << YAML::BeginMap;
+            for(unsigned i = 0; i < c->getNumDisplays(); ++i)
             {
-                TransformDirection val;
-                if (iter.second().Type() != YAML::NodeType::Null && 
-                    iter.second().Read<TransformDirection>(val))
-                  t->setDirection(val);
+                const char* display = c->getDisplay(i);
+                out << YAML::Key << display;
+                out << YAML::Value << YAML::BeginSeq;
+                for(unsigned v = 0; v < c->getNumViews(display); ++v)
+                {
+                    View dview;
+                    dview.name = c->getView(display, v);
+                    dview.colorspace = c->getDisplayColorSpaceName(display, dview.name.c_str());
+                    if(c->getDisplayLooks(display, dview.name.c_str()) != NULL)
+                        dview.looks = c->getDisplayLooks(display, dview.name.c_str());
+                    save(out, dview);
+                
+                }
+                out << YAML::EndSeq;
             }
-            else
+            out << YAML::EndMap;
+            
+#ifndef OLDYAML
+            out << YAML::Newline;
+#endif
+            out << YAML::Newline;
+            out << YAML::Key << "active_displays";
+            std::vector<std::string> active_displays;
+            if(c->getActiveDisplays() != NULL && strlen(c->getActiveDisplays()) > 0)
+                SplitStringEnvStyle(active_displays, c->getActiveDisplays());
+            out << YAML::Value << YAML::Flow << active_displays;
+            out << YAML::Key << "active_views";
+            std::vector<std::string> active_views;
+            if(c->getActiveViews() != NULL && strlen(c->getActiveViews()) > 0)
+                SplitStringEnvStyle(active_views, c->getActiveViews());
+            out << YAML::Value << YAML::Flow << active_views;
+#ifndef OLDYAML
+            out << YAML::Newline;
+#endif
+            
+            // Looks
+            if(c->getNumLooks() > 0)
             {
-                LogUnknownKeyWarning(node.Tag(), iter.first());
+                out << YAML::Newline;
+                out << YAML::Key << "looks";
+                out << YAML::Value << YAML::BeginSeq;
+                for(unsigned i = 0; i < c->getNumLooks(); ++i)
+                {
+                    const char* name = c->getLookNameByIndex(i);
+                    save(out, c->getLook(name));
+                }
+                out << YAML::EndSeq;
+                out << YAML::Newline;
             }
+            
+            // ColorSpaces
+            {
+                out << YAML::Newline;
+                out << YAML::Key << "colorspaces";
+                out << YAML::Value << YAML::BeginSeq;
+                for(unsigned i = 0; i < c->getNumColorSpaces(); ++i)
+                {
+                    const char* name = c->getColorSpaceNameByIndex(i);
+                    save(out, c->getColorSpace(name));
+                }
+                out << YAML::EndSeq;
+            }
+            
+            out << YAML::EndMap;
         }
+        
     }
     
-    YAML::Emitter& operator << (YAML::Emitter& out, ConstTruelightTransformRcPtr t)
+    ///////////////////////////////////////////////////////////////////////////
+    
+    void OCIOYaml::open(std::istream& istream, ConfigRcPtr& c, const char* filename) const
     {
-        
-        out << YAML::VerbatimTag("TruelightTransform");
-        out << YAML::Flow << YAML::BeginMap;
-        if(strcmp(t->getConfigRoot(), "") != 0)
+        try
         {
-            out << YAML::Key << "config_root";
-            out << YAML::Value << YAML::Flow << t->getConfigRoot();
+#ifdef OLDYAML
+            YAML::Parser parser(istream);
+            YAML::Node node;
+            parser.GetNextDocument(node);
+#else
+            YAML::Node node = YAML::Load(istream);
+#endif
+            load(node, c, filename);
         }
-        if(strcmp(t->getProfile(), "") != 0)
+        catch(const std::exception & e)
         {
-            out << YAML::Key << "profile";
-            out << YAML::Value << YAML::Flow << t->getProfile();
+            std::ostringstream os;
+            os << "Error: Loading the OCIO profile ";
+            if(filename) os << "'" << filename << "' ";
+            os << "failed. " << e.what();
+            throw Exception(os.str().c_str());
         }
-        if(strcmp(t->getCamera(), "") != 0)
-        {
-            out << YAML::Key << "camera";
-            out << YAML::Value << YAML::Flow << t->getCamera();
-        }
-        if(strcmp(t->getInputDisplay(), "") != 0)
-        {
-            out << YAML::Key << "input_display";
-            out << YAML::Value << YAML::Flow << t->getInputDisplay();
-        }
-        if(strcmp(t->getRecorder(), "") != 0)
-        {
-            out << YAML::Key << "recorder";
-            out << YAML::Value << YAML::Flow << t->getRecorder();
-        }
-        if(strcmp(t->getPrint(), "") != 0)
-        {
-            out << YAML::Key << "print";
-            out << YAML::Value << YAML::Flow << t->getPrint();
-        }
-        if(strcmp(t->getLamp(), "") != 0)
-        {
-            out << YAML::Key << "lamp";
-            out << YAML::Value << YAML::Flow << t->getLamp();
-        }
-        if(strcmp(t->getOutputCamera(), "") != 0)
-        {
-            out << YAML::Key << "output_camera";
-            out << YAML::Value << YAML::Flow << t->getOutputCamera();
-        }
-        if(strcmp(t->getDisplay(), "") != 0)
-        {
-            out << YAML::Key << "display";
-            out << YAML::Value << YAML::Flow << t->getDisplay();
-        }
-        if(strcmp(t->getCubeInput(), "") != 0)
-        {
-            out << YAML::Key << "cube_input";
-            out << YAML::Value << YAML::Flow << t->getCubeInput();
-        }
-        
-        EmitBaseTransformKeyValues(out, t);
-        
-        out << YAML::EndMap;
-        return out;
     }
     
-    ///////////////////////////////////////////////////////////////////////////
-    //  Enums
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, BitDepth depth) {
-        out << BitDepthToString(depth);
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, BitDepth& depth) {
-        std::string str;
-        node.Read<std::string>(str);
-        depth = BitDepthFromString(str.c_str());
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, Allocation alloc) {
-        out << AllocationToString(alloc);
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, Allocation& alloc) {
-        std::string str;
-        node.Read<std::string>(str);
-        alloc = AllocationFromString(str.c_str());
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, ColorSpaceDirection dir) {
-        out << ColorSpaceDirectionToString(dir);
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, ColorSpaceDirection& dir) {
-        std::string str;
-        node.Read<std::string>(str);
-        dir = ColorSpaceDirectionFromString(str.c_str());
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, TransformDirection dir) {
-        out << TransformDirectionToString(dir);
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, TransformDirection& dir) {
-        std::string str;
-        node.Read<std::string>(str);
-        dir = TransformDirectionFromString(str.c_str());
-    }
-    
-    YAML::Emitter& operator << (YAML::Emitter& out, Interpolation interp) {
-        out << InterpolationToString(interp);
-        return out;
-    }
-    
-    void operator >> (const YAML::Node& node, Interpolation& interp) {
-        std::string str;
-        node.Read<std::string>(str);
-        interp = InterpolationFromString(str.c_str());
+    void OCIOYaml::write(std::ostream& ostream, const Config* c) const
+    {
+        YAML::Emitter out;
+        save(out, c);
+        ostream << out.c_str();
     }
     
 }
