$OpenBSD: patch-lib_efi_loader_efi_boottime_c,v 1.1 2018/08/03 02:57:33 jsg Exp $

revert 4182a129ef735bfd6c54788affe1b649ab85b851
efi_loader: allocate configuration table array

After this commit, the ConfigurationTable field of the system table
is no longer translated from a physical address into a virtual address
when the SerVirtualAddressMap() runtime service gets called.

Broke boot on Orange Pi PC 2.

Index: lib/efi_loader/efi_boottime.c
--- lib/efi_loader/efi_boottime.c.orig
+++ lib/efi_loader/efi_boottime.c
@@ -35,6 +35,16 @@ LIST_HEAD(efi_events);
  */
 static bool efi_is_direct_boot = true;
 
+/*
+ * EFI can pass arbitrary additional "tables" containing vendor specific
+ * information to the payload. One such table is the FDT table which contains
+ * a pointer to a flattened device tree blob.
+ *
+ * In most cases we want to pass an FDT to the payload, so reserve one slot of
+ * config table space for it. The pointer gets populated by do_bootefi_exec().
+ */
+static struct efi_configuration_table __efi_runtime_data efi_conf_table[16];
+
 #ifdef CONFIG_ARM
 /*
  * The "gd" pointer lives in a register on ARM and AArch64 that we declare
@@ -1392,9 +1402,9 @@ static efi_status_t EFIAPI efi_locate_handle_ext(
  */
 static void efi_remove_configuration_table(int i)
 {
-	struct efi_configuration_table *this = &systab.tables[i];
-	struct efi_configuration_table *next = &systab.tables[i + 1];
-	struct efi_configuration_table *end = &systab.tables[systab.nr_tables];
+	struct efi_configuration_table *this = &efi_conf_table[i];
+	struct efi_configuration_table *next = &efi_conf_table[i + 1];
+	struct efi_configuration_table *end = &efi_conf_table[systab.nr_tables];
 
 	memmove(this, next, (ulong)end - (ulong)next);
 	systab.nr_tables--;
@@ -1422,9 +1432,9 @@ efi_status_t efi_install_configuration_table(const efi
 
 	/* Check for guid override */
 	for (i = 0; i < systab.nr_tables; i++) {
-		if (!guidcmp(guid, &systab.tables[i].guid)) {
+		if (!guidcmp(guid, &efi_conf_table[i].guid)) {
 			if (table)
-				systab.tables[i].table = table;
+				efi_conf_table[i].table = table;
 			else
 				efi_remove_configuration_table(i);
 			goto out;
@@ -1435,12 +1445,12 @@ efi_status_t efi_install_configuration_table(const efi
 		return EFI_NOT_FOUND;
 
 	/* No override, check for overflow */
-	if (i >= EFI_MAX_CONFIGURATION_TABLES)
+	if (i >= ARRAY_SIZE(efi_conf_table))
 		return EFI_OUT_OF_RESOURCES;
 
 	/* Add a new entry */
-	memcpy(&systab.tables[i].guid, guid, sizeof(*guid));
-	systab.tables[i].table = table;
+	memcpy(&efi_conf_table[i].guid, guid, sizeof(*guid));
+	efi_conf_table[i].table = table;
 	systab.nr_tables = i + 1;
 
 out:
@@ -3129,7 +3139,7 @@ struct efi_system_table __efi_runtime_data systab = {
 	.runtime = (void *)&efi_runtime_services,
 	.boottime = (void *)&efi_boot_services,
 	.nr_tables = 0,
-	.tables = NULL,
+	.tables = (void *)efi_conf_table,
 };
 
 /**
@@ -3139,18 +3149,9 @@ struct efi_system_table __efi_runtime_data systab = {
  */
 efi_status_t efi_initialize_system_table(void)
 {
-	efi_status_t ret;
-
-	/* Allocate configuration table array */
-	ret = efi_allocate_pool(EFI_RUNTIME_SERVICES_DATA,
-				EFI_MAX_CONFIGURATION_TABLES *
-				sizeof(struct efi_configuration_table),
-				(void **)&systab.tables);
-
 	/* Set crc32 field in table headers */
 	efi_update_table_header_crc32(&systab.hdr);
 	efi_update_table_header_crc32(&efi_runtime_services.hdr);
 	efi_update_table_header_crc32(&efi_boot_services.hdr);
-
-	return ret;
+	return EFI_SUCCESS;
 }
