$OpenBSD: patch-dialects_n+obsd_dproc_c,v 1.3 2016/09/25 16:46:01 sthen Exp $
--- dialects/n+obsd/dproc.c.orig	Wed May 11 22:54:00 2005
+++ dialects/n+obsd/dproc.c	Fri Sep 23 09:04:57 2016
@@ -40,7 +40,6 @@ static char *rcsid = "$Id: dproc.c,v 1.17 2005/05/11 1
 
 _PROTOTYPE(static void enter_vn_text,(KA_T va, int *n));
 _PROTOTYPE(static void get_kernel_access,(void));
-_PROTOTYPE(static void process_text,(KA_T vm));
 
 
 /*
@@ -172,7 +171,10 @@ gather_proc_info()
 	static int pofb = 0;
 #endif	/* defined(HASFSTRUCT) */
 
-#if	defined(HASKVMGETPROC2)
+#if	defined(HASKVMGETPROCS)
+	struct kinfo_proc *p;
+#define	KVMPROCSZ	sizeof(struct kinfo_proc)
+#elif	defined(HASKVMGETPROC2)
 	struct kinfo_proc2 *p;
 #define	KVMPROCSZ2	sizeof(struct kinfo_proc2)
 #else	/* !defined(HASKVMGETPROC2) */
@@ -183,11 +185,13 @@ gather_proc_info()
  * Read the process table.
  */
 
-#if	defined(HASKVMGETPROC2)
+#if	defined(HASKVMGETPROCS)
+	P = kvm_getprocs(Kd, KERN_PROC_ALL, 0, KVMPROCSZ, &Np);
+#elif	defined(HASKVMGETPROC2)
 	P = kvm_getproc2(Kd, KERN_PROC_ALL, 0, KVMPROCSZ2, &Np);
 #else	/* !defined(HASKVMGETPROC2) */
 	P = kvm_getprocs(Kd, KERN_PROC_ALL, 0, &Np);
-#endif	/* defined(HASKVMGETPROC2) &/
+#endif	/* defined(HASKVMGETPROC2) */
 
 	if (!P) {
 	    (void) fprintf(stderr, "%s: can't read process table: %s\n",
@@ -271,11 +275,6 @@ gather_proc_info()
 #endif	/* defined(OPENBSDV) && OPENBSDV>=3020 */
 
 	/*
-	 * Save information on the text file.
-	 */
-	    if (p->P_VMSPACE)
-		process_text((KA_T)p->P_VMSPACE);
-	/*
 	 * Read open file structure pointers.
 	 */
 	    if (!fd.fd_ofiles || (nf = fd.fd_nfiles) <= 0)
@@ -501,84 +500,4 @@ kread(addr, buf, len)
 
 	br = kvm_read(Kd, (u_long)addr, buf, len);
 	return((br == len) ? 0 : 1);
-}
-
-
-/*
- * process_text() - process text information
- */
-void
-process_text(vm)
-	KA_T vm;				/* kernel vm space pointer */
-{
-	int i, j;
-	KA_T ka;
-	int n = 0;
-	struct vm_map_entry vmme, *e;
-	struct vmspace vmsp;
-
-#if	!defined(UVM)
-	struct pager_struct pg;
-	struct vm_object vmo;
-#endif	/* !defined(UVM) */
-
-/*
- * Read the vmspace structure for the process.
- */
-	if (kread(vm, (char *)&vmsp, sizeof(vmsp)))
-	    return;
-/*
- * Read the vm_map structure.  Search its vm_map_entry structure list.
- */
-
-#if	!defined(UVM)
-	if (!vmsp.vm_map.is_main_map)
-	    return;
-#endif	/* !defined(UVM) */
-
-	for (i = 0; i < vmsp.vm_map.nentries; i++) {
-
-	/*
-	 * Read the next vm_map_entry.
-	 */
-	    if (!i)
-		e = &vmsp.vm_map.header;
-	    else {
-		if (!(ka = (KA_T)e->next))
-		    return;
-		e = &vmme;
-		if (kread(ka, (char *)e, sizeof(vmme)))
-		    return;
-	    }
-
-#if	defined(UVM)
-	/*
-	 * Process the uvm_obj pointer of a UVM map entry with a UVM_ET_OBJ
-	 * type as a vnode pointer.
-	 */
-	    if ((e->etype > UVM_ET_OBJ) && e->object.uvm_obj)
-		(void) enter_vn_text((KA_T)e->object.uvm_obj, &n);
-#else	/* !defined(UVM) */
-	/*
-	 * Read the map entry's object and the object's shadow.
-	 * Look for a PG_VNODE pager handle.
-	 */
-	    if (e->is_a_map || e->is_sub_map)
-		continue;
-	    for (j = 0, ka = (KA_T)e->object.vm_object;
-		 j < 2 && ka;
-		 j++, ka = (KA_T)vmo.shadow)
-	    {
-		if (kread(ka, (char *)&vmo, sizeof(vmo)))
-		    break;
-		if (!(ka = (KA_T)vmo.pager)
-		||   kread(ka, (char *)&pg, sizeof(pg)))
-		    continue;
-		if (!pg.pg_handle || pg.pg_type != PG_VNODE)
-		    continue;
-		(void) enter_vn_text((KA_T)pg.pg_handle, &n);
-	    }
-#endif	/* defined(UVM) */
-
-	}
 }
