$OpenBSD: patch-runtime_nsd_gtls_c,v 1.2 2016/03/06 12:18:31 ajacoutot Exp $

GnuTLS >= 2.12 does not depend on libgcrypt initialization any longer
and may in fact not use libgcrypt at all.

Fix build with GnuTLS 3.4.

--- runtime/nsd_gtls.c.orig	Sat Mar  5 19:44:38 2016
+++ runtime/nsd_gtls.c	Sat Mar  5 19:45:38 2016
@@ -29,7 +29,9 @@
 #include <string.h>
 #include <gnutls/gnutls.h>
 #include <gnutls/x509.h>
+#if GNUTLS_VERSION_NUMBER <= 0x020b00
 #include <gcrypt.h>
+#endif
 #include <errno.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -53,7 +55,9 @@
 #define CRLFILE "crl.pem"
 
 
+#if GNUTLS_VERSION_NUMBER <= 0x020b00
 GCRY_THREAD_OPTION_PTHREAD_IMPL;
+#endif
 MODULE_TYPE_LIB
 
 /* static data */
@@ -225,13 +229,13 @@ static int
 gtlsClientCertCallback(gnutls_session session,
               __attribute__((unused)) const gnutls_datum* req_ca_rdn, int __attribute__((unused)) nreqs,
               __attribute__((unused)) const gnutls_pk_algorithm* sign_algos, int __attribute__((unused)) sign_algos_length,
-              gnutls_retr_st *st)
+              gnutls_retr2_st *st)
 {
 	nsd_gtls_t *pThis;
 
 	pThis = (nsd_gtls_t*) gnutls_session_get_ptr(session);
 
-	st->type = GNUTLS_CRT_X509;
+	st->cert_type = GNUTLS_CRT_X509;
 	st->ncerts = 1;
 	st->cert.x509 = &pThis->ourCert;
 	st->key.x509 = pThis->ourKey;
@@ -559,8 +563,10 @@ gtlsGlblInit(void)
 	uchar *cafile;
 	DEFiRet;
 
+#if GNUTLS_VERSION_NUMBER <= 0x020b00
 	/* gcry_control must be called first, so that the thread system is correctly set up */
 	gcry_control (GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);
+#endif
 	CHKgnutls(gnutls_global_init());
 	
 	/* X509 stuff */
@@ -1610,7 +1616,7 @@ Connect(nsd_t *pNsd, int family, uchar *port, uchar *h
 	gnutls_session_set_ptr(pThis->sess, (void*)pThis);
 	iRet = gtlsLoadOurCertKey(pThis); /* first load .pem files */
 	if(iRet == RS_RET_OK) {
-		gnutls_certificate_client_set_retrieve_function(xcred, gtlsClientCertCallback);
+		gnutls_certificate_set_retrieve_function(xcred, gtlsClientCertCallback);
 	} else if(iRet != RS_RET_CERTLESS) {
 		FINALIZE; /* we have an error case! */
 	}
