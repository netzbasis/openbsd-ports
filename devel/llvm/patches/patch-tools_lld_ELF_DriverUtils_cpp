$OpenBSD: patch-tools_lld_ELF_DriverUtils_cpp,v 1.4 2017/04/17 14:20:17 ajacoutot Exp $

- Disable colored diagnostics.
- Print out "supported targets".
- Refine comment.
- [ELF] Print two more MIPS targets "supported" by LLD
- Handle the OpenBSD-style major/minor shared library version scheme.

--- tools/lld/ELF/DriverUtils.cpp.orig	Fri Jan  6 05:04:35 2017
+++ tools/lld/ELF/DriverUtils.cpp	Sun Apr 16 15:32:46 2017
@@ -59,7 +59,7 @@ static bool getColorDiagnostics(opt::InputArgList &Arg
   auto *Arg = Args.getLastArg(OPT_color_diagnostics, OPT_color_diagnostics_eq,
                               OPT_no_color_diagnostics);
   if (!Arg)
-    return Default;
+    return false;
   if (Arg->getOption().getID() == OPT_color_diagnostics)
     return true;
   if (Arg->getOption().getID() == OPT_no_color_diagnostics)
@@ -120,6 +120,20 @@ opt::InputArgList ELFOptTable::parse(ArrayRef<const ch
 void elf::printHelp(const char *Argv0) {
   ELFOptTable Table;
   Table.PrintHelp(outs(), Argv0, "lld", false);
+  outs() << "\n";
+
+  // Scripts generated by Libtool versions up to at least 2.4.6 (the most
+  // recent version as of March 2017) expect /: supported targets:.* elf/
+  // in a message for the -help option. If it doesn't match, the scripts
+  // assume that the linker doesn't support very basic features such as
+  // shared libraries. Therefore, we need to print out at least "elf".
+  // Here, we print out all the targets that we support.
+  outs() << Argv0 << ": supported targets: "
+         << "elf32-i386 elf32-iamcu elf32-littlearm elf32-powerpc "
+         << "elf32-tradbigmips elf32-tradlittlemips "
+         << "elf32-ntradbigmips elf32-ntradlittlemips elf32-x86-64 "
+         << "elf64-amdgpu elf64-littleaarch64 elf64-powerpc "
+         << "elf64-tradbigmips elf64-tradlittlemips elf64-x86-64\n";
 }
 
 // Reconstructs command line arguments so that so that you can re-run
@@ -180,9 +194,35 @@ Optional<std::string> elf::searchLibrary(StringRef Nam
     return findFromSearchPaths(Name.substr(1));
 
   for (StringRef Dir : Config->SearchPaths) {
-    if (!Config->Static)
+    if (!Config->Static) {
       if (Optional<std::string> S = findFile(Dir, "lib" + Name + ".so"))
         return S;
+
+      llvm::SmallString<128> Scratch;
+      const StringRef LibName = ("lib" + Name + ".so.").toStringRef(Scratch);
+      int MaxMaj = -1, MaxMin = -1;
+      std::error_code EC;
+      for (fs::directory_iterator LI(Dir, EC), LE;
+	   !EC && LI != LE; LI = LI.increment(EC)) {
+        StringRef FilePath = LI->path();
+	StringRef FileName = path::filename(FilePath);
+	if (!(FileName.startswith(LibName)))
+	  continue;
+	std::pair<StringRef, StringRef> MajMin =
+	  FileName.substr(LibName.size()).split('.');
+	int Maj, Min;
+	if (MajMin.first.getAsInteger(10, Maj) || Maj < 0)
+	  continue;
+	if (MajMin.second.getAsInteger(10, Min) || Min < 0)
+	  continue;
+	if (Maj > MaxMaj)
+	  MaxMaj = Maj, MaxMin = Min;
+	if (MaxMaj == Maj && Min > MaxMin)
+	  MaxMin = Min;
+      }
+      if (MaxMaj >= 0)
+	return findFile(Dir, LibName + Twine(MaxMaj) + "." + Twine(MaxMin));
+    }
     if (Optional<std::string> S = findFile(Dir, "lib" + Name + ".a"))
       return S;
   }
