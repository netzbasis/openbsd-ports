$OpenBSD: patch-tools_lld_ELF_Driver_cpp,v 1.3 2017/03/23 08:26:07 ajacoutot Exp $

- ELF: Add /usr/lib as default search path.

  GNU ld and gold have this path as default search path.
  If you don't want this directory, pass -nostdlib.
- Enable PIE by default.
- [ELF] Add -z nodlopen option.
- Add "(compatible with GNU linkers)" to the -version output.

--- tools/lld/ELF/Driver.cpp.orig	Wed Feb  1 17:45:57 2017
+++ tools/lld/ELF/Driver.cpp	Wed Mar 22 18:55:19 2017
@@ -281,11 +281,27 @@ void LinkerDriver::main(ArrayRef<const char *> ArgsArr
     return;
   }
 
-  // GNU linkers disagree here. Though both -version and -v are mentioned
-  // in help to print the version information, GNU ld just normally exits,
-  // while gold can continue linking. We are compatible with ld.bfd here.
-  if (Args.hasArg(OPT_version) || Args.hasArg(OPT_v))
-    outs() << getLLDVersion() << "\n";
+  // Handle -v or -version.
+  //
+  // A note about "compatible with GNU linkers" message: this is a hack for
+  // scripts generated by GNU Libtool 2.4.6 (released in February 2014 and
+  // still the newest version in March 2017) or earlier to recognize LLD as
+  // a GNU compatible linker. As long as an output for the -v option
+  // contains "GNU" or "with BFD", they recognize us as GNU-compatible.
+  //
+  // This is somewhat ugly hack, but in reality, we had no choice other
+  // than doing this. Considering the very long release cycle of Libtool,
+  // it is not easy to improve it to recognize LLD as a GNU compatible
+  // linker in a timely manner. Even if we can make it, there are still a
+  // lot of "configure" scripts out there that are generated by old version
+  // of Libtool. We cannot convince every software developer to migrate to
+  // the latest version and re-generate scripts. So we have this hack.
+  if (Args.hasArg(OPT_v) || Args.hasArg(OPT_version))
+    outs() << getLLDVersion() << " (compatible with GNU linkers)\n";
+
+  // ld.bfd always exits after printing out the version string.
+  // ld.gold proceeds if a given option is -v. Because gold's behavior
+  // is more permissive than ld.bfd, we chose what gold does here.
   if (Args.hasArg(OPT_version))
     return;
 
@@ -459,6 +475,9 @@ static std::vector<StringRef> getLines(MemoryBufferRef
 
 // Initializes Config members by the command line options.
 void LinkerDriver::readConfigs(opt::InputArgList &Args) {
+  if (!Args.hasArg(OPT_nostdlib))
+    Config->SearchPaths.push_back("=/usr/lib");
+
   for (auto *Arg : Args.filtered(OPT_L))
     Config->SearchPaths.push_back(Arg->getValue());
 
@@ -493,7 +512,8 @@ void LinkerDriver::readConfigs(opt::InputArgList &Args
   Config->NoUndefinedVersion = Args.hasArg(OPT_no_undefined_version);
   Config->Nostdlib = Args.hasArg(OPT_nostdlib);
   Config->OMagic = Args.hasArg(OPT_omagic);
-  Config->Pie = getArg(Args, OPT_pie, OPT_nopie, false);
+  Config->Pie = getArg(Args, OPT_pie, OPT_nopie,
+      !Args.hasArg(OPT_shared) && !Args.hasArg(OPT_relocatable));
   Config->PrintGcSections = Args.hasArg(OPT_print_gc_sections);
   Config->Relocatable = Args.hasArg(OPT_relocatable);
   Config->DefineCommon = getArg(Args, OPT_define_common, OPT_no_define_common,
@@ -532,6 +552,7 @@ void LinkerDriver::readConfigs(opt::InputArgList &Args
   Config->ZCombreloc = !hasZOption(Args, "nocombreloc");
   Config->ZExecstack = hasZOption(Args, "execstack");
   Config->ZNodelete = hasZOption(Args, "nodelete");
+  Config->ZNodlopen = hasZOption(Args, "nodlopen");
   Config->ZNow = hasZOption(Args, "now");
   Config->ZOrigin = hasZOption(Args, "origin");
   Config->ZRelro = !hasZOption(Args, "norelro");
