#! /usr/bin/perl
# $OpenBSD: update-plist,v 1.13 2018/04/26 18:28:58 espie Exp $
# Copyright (c) 2018 Marc Espie <espie@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use OpenBSD::PkgCreate;
use Data::Dumper;
use File::Find;
use File::Spec;
my $ports1;
my ($ports_uid, $ports_gid, $fake_uid, $fake_gid);
BEGIN {
	$ports1 = $ENV{PORTSDIR} || '/usr/ports';
	# if we're root
	return if $< != 0;
	# switch id right away
	my $fake = $ENV{FAKE_TREE_OWNER};
	my $tree = $ENV{PORTS_TREE_OWNER};
	# XXX we can only end there if we're very naughty and building
	# everything as root, but not behind PORTS_PRIVSEP
	if (!defined $fake && !defined $tree) {
		print STDERR "DON'T BUILD PORTS AS ROOT!!!!!\n";
		print STDERR "(or make sure you pass env variables PORTS_TREE_OWNER and FAKE_TREE_OWNER thru doas to root)\n";
		return;
	}
	die "FAKE_TREE_OWNER not defined" unless defined $fake;
	die "PORTS_TREE_OWNER not defined" unless defined $tree;

	($fake_uid, $fake_gid) = (getpwnam $fake)[2,3];
	($ports_uid, $ports_gid) = (getpwnam $tree)[2,3];
	die "User $fake not found" unless defined $fake_uid;
	die "User $tree not found" unless defined $ports_uid;
	$) = $fake_gid;
	$> = $fake_uid;
}
use lib "$ports1/infrastructure/lib";

package Forwarder;
# perfect forwarding
sub AUTOLOAD
{
	our $AUTOLOAD;
	my $fullsub = $AUTOLOAD;
	(my $sub = $fullsub) =~ s/.*:://o;
	return if $sub eq 'DESTROY'; # special case
	no strict "refs";
	*$fullsub = sub {
		my $self = shift;
		$self->{delegate}->$sub(@_);
	};
	goto &$fullsub;
}

package ReverseSubst;
our @ISA = qw(Forwarder);
sub new
{
	bless {delegate => OpenBSD::Subst->new, l => []}, shift;
}

sub add
{
	my ($self, $k, $v) = @_;
	push(@{$self->{l}}, $k);
	$self->{delegate}->add($k, $v);
}

package MyFile;
use File::Basename;
sub pretty
{
	my $self = shift;
	return basename($self->{name});
}

package PlistReader;
our @ISA = qw(OpenBSD::PkgCreate);

# this is where the magic happens:
# e is the plist element
# self is the reader (with pkgname et al)
# file is the fileclass where this comes from
# unsubst is the full name before substitution
sub annotate
{
	my ($self, $e, $unsubst, $file) = @_;
	$e->{unsubst} = $unsubst;
	$e->{file} = $file;
	$e->{comesfrom} = $self;
}

# okay, so that plist doesn't exist, wouhou, I don't care,
# since I'm not pkg_create
sub cant_read_fragment
{
}

sub missing_fragments
{
}

sub new
{
	my $class = shift;
	bless { olist => OpenBSD::PackingList->new,
		nlist => OpenBSD::PackingList->new }, $class;
}

sub olist
{
	my $self = shift;
	return $self->{olist};
}

sub nlist
{
	my $self = shift;
	return $self->{nlist};
}

sub strip_prefix
{
	my ($self, $path) = @_;
	$path =~ s,^\Q$self->{state}{prefix}\E/,,;
	return $path;
}

package PlistReader::State;
our @ISA = qw(OpenBSD::PkgCreate::State);

sub init
{
	my ($self, $realstate) = @_;
	$self->{subst} = ReverseSubst->new;
	$self->{progressmeter} = $realstate->{progressmeter};
	$self->{bad} = 0;
	$self->{repo} = $realstate->{repo};
}

package UpdatePlist::State;
our @ISA = qw(OpenBSD::AddCreateDelete::State);
sub handle_options
{
	my $state = shift;
	$state->{opt} = {
		'X' => sub {
			my $path = shift;
			$state->{ignored}{$path} = 1;
		    },
	};
	$state->SUPER::handle_options('X:', 
	    '[mnx] [-X path] -- pkg_create_args ...');
}

package OpenBSD::PackingElement;
sub known_object
{
}

sub known_directory
{
}

sub show_unknown
{
}

sub copy_annotations
{
}

package OpenBSD::PackingElement::Meta;
sub copy_annotations
{
	my ($self, $plist) = @_;
	$self->clone->add_object($plist);
}

package OpenBSD::PackingElement::CVSTag;
sub copy_annotations
{
	my ($self, $plist) = @_;
	$self->clone->add_object($plist);
}

package OpenBSD::PackingElement::NewAuth;
sub copy_annotations
{
	&OpenBSD::PackingElement::Meta::copy_annotations;
}

# these are not really in the plist on disk!
package OpenBSD::PackingElement::Name;
sub copy_annotations
{
}

package OpenBSD::PackingElement::SpecialFile;
sub copy_annotations
{
}

package OpenBSD::PackingElement::ExtraInfo;
sub copy_annotations
{
}

package OpenBSD::PackingElement::Comment;
sub fullname
{
	my $self = shift;
	# let's pretend we're an object!!!
	my $path = $self->name;
	if ($path !~ m|^/|o && $self->cwd ne '.') {
		$path = $self->cwd."/".$path;
		$path =~ s,^//,/,;
	}
	return $path;
}

sub known_object
{
	&OpenBSD::PackingElement::FileObject::known_object;
}

sub cwd
{
	&OpenBSD::PackingElement::Object::cwd;
}

sub copy_annotations
{
	# nope these are not normal annotations
}

package OpenBSD::PackingElement::FileObject;
use File::Basename;

sub known_object
{
	my ($self, $h, $ap) = @_;
	my $f = $self->fullname;
	push @{$h->{$f}}, $self;
	delete $ap->{$f};
}

sub known_directory
{
	my ($self, $h, $plist) = @_;
	my $d = $self->fullname;
	while (1) {
		$d = dirname($d);
		# don't go up to / if we can avoid it
		return if $d eq $self->cwd or $d eq '/';
		return if defined $self->{$d}{$plist};
		$h->{$d}{$plist} = $self;
	}
}

sub show_unknown
{
	my $self = shift;
	if (!$self->{found}) {
		print "Not found: ", $self->fullname, "(in ", $self->{file}->pretty, ")\n";
	}
}

package UpdatePlist;
use  File::Basename;

my $state = UpdatePlist::State->new('update-plist');

# this handles update-plist options proper, finished with --
$state->handle_options;

my @lists;
my $exact = {};
my $approximate = {};
my $dependencies = {};

# we read all plists using the exact same code as pkg_create
# e.g., ARGV is all PKG_ARGS*  parameters concatenated together:
# options1 pkgname1 options2 pkgname2 ...
while (@ARGV > 0) {
	my $r = PlistReader->new;

	my $s = PlistReader::State->new('update-plist', $state);
	$r->{state} = $s;
	$s->handle_options;
	$s->{opt}{q} = 1;
	die "bad arguments to update-plist" if @{$s->{contents}} != 1;
	$r->{base_plistname} = $s->{contents}->[0];
	push(@lists, $r);
	my $pkg = shift;

	$r->olist->set_pkgname($pkg);
	$r->nlist->set_pkgname($pkg);
	$r->read_all_fragments($s, $r->olist);
	$r->add_extra_info($r->olist, $s);
	# for removing directory stuff later on
	$dependencies->{$r->olist->fullpkgpath} = $r->nlist;
# except that we also record where each object live, including directory
# locations.  As a rule, "exact" information will supersede deduced directory
# names.
	$r->olist->known_directory($approximate, $r->olist);
	$r->olist->known_object($exact, $approximate);
	$state->say("Processed #1 as #2", $pkg, $r->olist->fullpkgpath);
}

# XXX we assume all subpackage are under the same destdir (-B option)
my $base = $lists[0]->{state}{base};

# now we ask the file system what exists, and fill file objects according to
# that.
require OpenBSD::FS2;
$state->say("Scanning #1", $base);
my $objects = OpenBSD::FS2->fill($base, $state->{ignored});

$state->say("Matching objects");

# we will match fs objects to read plists as best as we can
for my $path (sort keys %$objects) {
	if ($exact->{$path}) {
#		print $path, " -> ", $exact->{$path}[0]{file}->pretty, "\n";
		for my $e (@{$exact->{$path}}) {
			$e->{found} = 1;
		}
	} else {
#		print $path, " ??? ", ref($path), "\n";
	}
}

# once we figured out existing object, we try to preserve @exec and similar
# info as best as we can.

#for my $s (@$states) {
#	$s->plist->tie_objects;
#}

$state->say("Copying objects");
for my $path (sort keys %$objects) {
	if ($exact->{$path}) {
		# this will be re-added to multiple paths if there are
		# multiple matching plists
		for my $e (@{$exact->{$path}}) {
			my $s = $e->{comesfrom};
			$e->add_object($s->nlist);
		}
		next;
	}

	# we didn't find it so we must create a new one
	my $o = $objects->{$path};
	# go up dir until we find a matching approximate dir
	my $d = $path;
	while (1) {
		$d = dirname($d);
		last if $d eq '/';
		next unless exists $approximate->{$d};
		my @l = values %{$approximate->{$d}};
		# if we do, we only write non ambiguous names
		if (@l == 1) {
			my $s = $l[0]->{comesfrom};
			$o->element_class->add($s->nlist, 
			    $s->strip_prefix($path));
			last;
		}
	}
	# last resort
	$o->element_class->add($lists[0]->nlist, 
	    $lists[0]->strip_prefix($path));
}

for my $s (@lists) {
	$s->olist->copy_annotations($s->nlist);
}

use File::Path;
#make_path("tryout");
# switch to ports owner

$> = 0;
$) = $ports_gid;
$> = $ports_uid;

for my $s (@lists) {
	my $name = $s->{base_plistname}.".new";
	open(my $fh, '>', $name) or die "Can't open $name: $!";
	delete $s->nlist->{name};
	$s->nlist->write($fh);
}

# let's show a quick summary of stuff we couldn't figure out
for my $s (@lists) {
	$s->olist->show_unknown($exact);
}
