#! /usr/bin/perl
# $OpenBSD: update-plist,v 1.109 2018/05/06 16:14:20 espie Exp $
# Copyright (c) 2018 Marc Espie <espie@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

my $ports1;
my ($ports_uid, $ports_gid, $fake_uid, $fake_gid);
BEGIN {
	$ports1 = $ENV{PORTSDIR} || '/usr/ports';
	# if we're root
	return if $< != 0;
	# switch id right away
	my $fake = $ENV{FAKE_TREE_OWNER};
	my $tree = $ENV{PORTS_TREE_OWNER};
	# XXX we can only end there if we're very naughty and building
	# everything as root, but not behind PORTS_PRIVSEP
	if (!defined $fake && !defined $tree) {
		print STDERR "DON'T BUILD PORTS AS ROOT!!!!!\n";
		print STDERR "(or make sure you pass env variables PORTS_TREE_OWNER and FAKE_TREE_OWNER thru doas to root)\n";
		return;
	}
	die "FAKE_TREE_OWNER not defined" unless defined $fake;
	die "PORTS_TREE_OWNER not defined" unless defined $tree;

	($fake_uid, $fake_gid) = (getpwnam $fake)[2,3];
	($ports_uid, $ports_gid) = (getpwnam $tree)[2,3];
	die "User $fake not found" unless defined $fake_uid;
	die "User $tree not found" unless defined $ports_uid;
	$) = $fake_gid;
	$> = $fake_uid;
}
use lib "$ports1/infrastructure/lib";
use OpenBSD::PkgCreate;
use OpenBSD::FS2;

package TrackedFile;
sub new
{
	my ($class, $name) = @_;
	bless {name => $name, items => []}, $class;
}

sub add
{
	my ($self, $item) = @_;
	push(@{$self->{items}}, $item);
}

sub fh
{
	my $self = shift;
	if (!defined $self->{fh}) {
		my $full = $self->name.".new";
		open($self->{fh}, '>', $full) or die "Can't open $full: $!";
	}
	return $self->{fh};
}

sub name
{
	my $self = shift;
	return $self->{name};
}

sub next_item
{
	my $self = shift;
	if (@{$self->{items}} != 0) {
		return shift @{$self->{items}};
	} else {
		return undef;
	}
}

package TrackFile;

sub new
{
	my ($class, $default) = @_;
	my $self = bless {}, $class;
	$self->{known}{$default} = 
	    $self->{default} = TrackedFile->new($default);
	return $self;
}

sub file
{
	my ($self, $name) = @_;
	$self->{known}{$name} //= TrackedFile->new($name);
	return $self->{known}{$name};
}

sub default
{
	my $self = shift;
	return $self->{default};
}

sub write_all
{
	my ($self, $p) = @_;

	for my $i (@{$p->{base_plists}}) {
		# we mimic the way pkg_create writes files
		$p->{restate} = {};

		my @stack = ();
		push(@stack, $self->file($i));


		while (my $file = pop @stack) {
			while (my $i = $file->next_item) {
				my $filename = $i->write_restate($file, $p);
				if (defined $filename) {
					push(@stack, $file);
					$file = $self->file($filename);
				}
			}
			close($file->fh);
		}
	}
}

package Forwarder;
# perfect forwarding
sub AUTOLOAD
{
	our $AUTOLOAD;
	my $fullsub = $AUTOLOAD;
	(my $sub = $fullsub) =~ s/.*:://o;
	return if $sub eq 'DESTROY'; # special case
	no strict "refs";
	*$fullsub = sub {
		my $self = shift;
		$self->{delegate}->$sub(@_);
	};
	goto &$fullsub;
}

package ReverseSubst;
our @ISA = qw(Forwarder);
sub new
{
	bless {delegate => OpenBSD::Subst->new, 
	    # count the number of times we see each value. More than once,
	    # hard to figure out WHICH one to backsubst
	    count => {}, 
	    # record that a variable is actually used. Then if we see the
	    # string and no backsubst, it's probably intentional
	    used => {}, 
	    # special variables we won't add in substitutions
	    special => {
		FULLPKGNAME => 1,
		FULLPKGPATH => 1,
		MACHINE_ARCH => 1,
		ARCH => 1,
		BASE_PKGPATH => 1,
		LOCALSTATEDIR => 1,
	    },
	    # list of actual variables we care about, e.g., ignored stuff
	    # and whatnot
	    l => [],
	    # variables that expand to nothing have specific handling
	    lempty => [],
	    }, shift;
}

my $ignore = {
	COMMENT => 1,
	MAINTAINER => 1,
	PERMIT_PACKAGE_CDROM => 1,
	PERMIT_PACKAGE_FTP => 1,
	HOMEPAGE => 1,
	REVISION => 1,
	EPOCH => 1,
};



sub add
{
	my ($self, $k, $v) = @_;
	# XXX whatever is before FLAVORS is internal pkg_create options
	# so ignore them
	if ($k eq 'FLAVORS') {
		$self->{l} = [];
		$self->{count} = {};
		$self->{lempty} = [];
	}
	if ($ignore->{$k} || $k =~ m/^LIB\S+_VERSION$/) {
	} else {
		# any variable that expands to @comment should never get
		# added where it wasn't already
		if ($v =~ m/^\@comment\s*$/) {
			my $k2 = $k;
			$k2 =~ s/\^//;
			$self->{special}{$k2} = 1;
		}
		if ($v eq '') {
			unshift(@{$self->{lempty}}, $k);
		} else {
			unshift(@{$self->{l}}, $k);
		}
		$self->{count}{$v}++;
	}
	$self->{delegate}->add($k, $v);
}

sub value
{
	my ($self, $k) = @_;
	$k =~ s/\^//;
	return $self->{delegate}->value($k);
}

sub never_add
{
	my ($self, $k) = @_;
	if ($self->{count}{$self->value($k)} > 1) {
		return 1;
	} else {
		return $self->{special}{$k};
	}
}

# this has to call self's add in order for reverse_subst to work properly
sub parse_option
{
	&OpenBSD::Subst::parse_option;
}

sub do_backsubst
{
	my ($subst, $string, $unsubst) = @_;

	# sort non empty variables by reverse length
	$subst->{vars} //= [sort 
	    {length($subst->value($b)) <=> length($subst->value($a))} 
	    @{$subst->{l}}];
	for my $k (@{$subst->{vars}}) {
		my $k2 = $k;
		$k2 =~ s/^\^//;
		# don't add subst on THOSE variables
		# TODO ARCH, MACHINE_ARCH could happen, but only with word
		#  boundary contexts
		if ($subst->never_add($k2)) {
			unless (defined $unsubst &&
			    $unsubst =~ m/\$\{\Q$k2\E\}/) {
			    	# add a magical location for FULLPKGNAME
			    	next unless $k2 eq 'FULLPKGNAME' &&
				    $string =~ m,^share/doc/pkg-readmes/,;
			}
		} else {
			# Heuristics: if the variable is already known AND was 
			# not used already, then we don't try to use it
			next if defined $unsubst &&
			    $subst->{used}{$k2} &&
			    $unsubst !~ m/\$\{$k2\}/;
		}
		    	
		if ($k =~ m/^\^(.*)$/) {
			my $v = $subst->value($k2);
			$string =~ s/^\Q$v\E/\$\{$k2\}/;
			$string =~ s/([\s:=])\Q$v\E/$1\$\{$k2\}/g;
		} else {
			# TODO on the other hand, numeric and version-like
			# variables shouldn't substitute partial numbers
			my $v = $subst->value($k);
			$string =~ s/\Q$v\E/\$\{$k2\}/g;
		}
	}

	# we can't do empty subst without an unsubst;
	return $string unless defined $unsubst;

	# this part will be done repeatedly
	my $old;
	do {
		$old = $string;
		for my $k (@{$subst->{lempty}}) {
			my $k2 = $k;
			$k2 =~ s/^\^//;
			if ($unsubst =~ m/^(.*)\$\{$k2\}/) {
				my $prefix = $1;
				# XXX avoid infinite loop
				next if $string =~ m/\Q$prefix\E\$\{\Q$k2\E\}/;
				$string =~ s/^\Q$prefix\E/$prefix\$\{$k2\}/;
			}
		}
	} while ($old ne $string);
	return $string;
}

package PlistReader;
our @ISA = qw(OpenBSD::PkgCreate);

# this is where the magic happens:
# e is the plist element
# self is the reader (with pkgname et al)
# file is the fileclass where this comes from
# unsubst is the full name before substitution
sub annotate
{
	my ($self, $e, $s, $file) = @_;
	$e->{unsubst} = $s;
	$e->{file} = $file->name;
	$e->{comesfrom} = $self;

	# so we redo what subst does, but we mark it!

	return unless defined $s;
	return unless $s =~ m/\$/o;	# optimization
	my $subst = $self->{state}{subst};
	while ( my $k = ($s =~ m/\$\{([A-Za-z_][^\}]*)\}/o)[0] ) {
		my $v = $subst->value($k);
		$subst->{used}{$k} = 1;
		unless ( defined $v ) { $v = "\$\\\{$k\}"; }
		$s =~ s/\$\{\Q$k\E\}/$v/g;
	}
}

# and more magic, we want to record fragments as pseudo-objects
sub record_fragment
{
	my ($self, $plist, $not, $name, $file) = @_;
	my $f;
	if ($not) {
		$f = OpenBSD::PackingElement::NoFragment->add($plist, $name);
	} else {
		$f = OpenBSD::PackingElement::Fragment->add($plist, $name);
	}
	$self->annotate($f, undef, $file);
}


# okay, so that plist doesn't exist, wouhou, I don't care,
# since I'm not pkg_create
sub cant_read_fragment
{
}

sub missing_fragments
{
}

sub new
{
	my $class = shift;
	bless { olist => OpenBSD::PackingList->new,
		nlist => OpenBSD::PackingList->new }, $class;
}

sub olist
{
	my $self = shift;
	return $self->{olist};
}

sub nlist
{
	my $self = shift;
	return $self->{nlist};
}

sub strip_prefix
{
	my ($self, $path) = @_;
	$path =~ s,^\Q$self->{state}{prefix}\E/,,;
	return $path;
}

sub subst
{
	my $self = shift;
	return $self->{state}{subst};
}

sub figure_out_dependencies
{
	my ($self, $cache, $portsdir) = @_;
	my @solve = ();
	my $register = $self->{directory_register};
	for my $full (keys %{$self->{state}{dependencies}}) {
		next unless $full =~ m/^(.*?):/;
		push(@solve, $1);
	}
	while (@solve != 0) {
		# optimization: don't try if we don't have directories left
		return if !%$register;
		my $pkgpath = pop @solve;
		if (!defined $cache->{$pkgpath}) {
			$cache->{$pkgpath} = {};
			$self->{state}->say("Stripping directories from #1",
			    $pkgpath);
			my $plist = OpenBSD::Dependencies::CreateSolver->ask_tree(
			    $self->{state}, $pkgpath, $portsdir,
			    \&OpenBSD::PackingList::UpdatePlistOnly,
			    "print-plist-with-depends", "wantlib_args=no-wantlib-args");
			$plist->process_dependency($cache->{$pkgpath});
		}
		for my $dir (keys %{$cache->{$pkgpath}{dir}}) {
			if (defined $register->{$dir}) {
				$register->{$dir}{DONT} = 1;
				delete $register->{$dir};
			}
		}
		push(@solve, keys %{$cache->{$pkgpath}{pkgpath}});
	}
}

package PlistReader::State;
our @ISA = qw(OpenBSD::PkgCreate::State);

sub init
{
	my ($self, $realstate) = @_;
	$self->{subst} = ReverseSubst->new;
	$self->{progressmeter} = $realstate->{progressmeter};
	$self->{bad} = 0;
	$self->{repo} = $realstate->{repo};
}

package UpdatePlist::State;
our @ISA = qw(OpenBSD::AddCreateDelete::State);
sub handle_options
{
	my $state = shift;
	$state->{opt} = {
		'X' => sub {
			my $path = shift;
			$state->{ignored}{$path} = 1;
		    },
		'w' => sub {
			my $warn = shift;
			push(@{$state->{warn_suffix}}, $warn);
		},
	};
	$state->SUPER::handle_options('rX:P:w:', 
	    '[-mnrx] [-P pkgdir] [-w suffix] [-X path] -- pkg_create_args ...');
    	$state->{pkgdir} = $state->opt('P');
	$state->{scan_as_root} = $state->opt('r');
}

# copy_extra: stuff that can't be easily deduced but should be copied
package OpenBSD::PackingElement;
sub known_object
{
}

sub process_dependency
{
}

sub known_directory
{
}

sub copy_annotations
{
}

sub redistribute
{
	my ($o, $p) = @_;
	return if $o->{DONT};
	if (defined $o->{file}) {
		$p->{tracker}->file($o->{file})->add($o);
	} else {
		$p->{tracker}->default->add($o);
	}
}

sub write_restate
{
	my ($o, $file, $p) = @_;
	$o->write_backsubst($file, $p);
	return undef;
}

sub write_backsubst
{
	my ($o, $file, $p) = @_;
	my $s = $p->subst->do_backsubst($o->fullstring, $o->{unsubst});
	print {$file->fh} $s, "\n";
}

sub copy_extra
{
}

sub tag_along
{
	my ($self, $n) = @_;

	push(@{$self->{mytags}}, $n);
}

sub tie_objects
{
	my ($self, $plist) = @_;
	if ($self->{found}) {
		$self->bookmark($plist);
	} else {
		$self->may_tag_along($plist);
	}
}

sub attach_to_lastobject
{
	my ($self, $plist) = @_;
	if (defined $plist->{state}{lastobject}) {
		$plist->{state}{lastobject}->tag_along($self);
	}
}

sub bookmark
{
}

sub may_tag_along
{
}

sub tag_directories
{
}

sub bad_suffixes
{
}

sub find_existing_cvstags
{
	my ($self, $filenames, $existing) = @_;
	if (defined $self->{file}) {
		$filenames->{$self->{file}} = 1;
	}
}

sub show_unknown
{
	my $self = shift;
	if (!$self->{found}) {
		print "Not found: ", $self->fullstring, " (in ", 
		    $self->{file}, ")\n";
	}
}

sub copy_with_tags
{
	my ($self, $plist) = @_;

	$self->{found} = 1;
	$self->add_object($plist);
	if (defined $self->{mytags}) {
		for my $tag (@{$self->{mytags}}) {
			next if $tag->{found};
			copy_with_tags($tag, $plist);
		}
	}
}

# will be zero for classes that cannot be deduced from the FS
sub rebless_okay { 1 }

package OpenBSD::PackingElement::State;

# that stuff NEVER gets copied over, but interpolated from existing objects
sub show_unknown
{
}

# objects are (mostly) stuff with paths that can get substs...
package OpenBSD::PackingElement::Object;
sub bad_suffixes
{
	my ($self, $p, $state) = @_;

	# don't care if it's already in a PLIST
	return if defined $self->{comesfrom};
	my $s = $self->fullname;
	my $error;
	if ($s =~ m/\/\.[^\/]*\.swp$/) {
		$error = "vim swap file";
	} elsif ($s =~ m/\~$/) {
		$error = "emacs temporary file";
	} elsif ($s eq '/usr/local/lib/charset.alias' && 
	    $p->olist->fullpkgpath ne 'converters/libiconv') {
		$error = "file from converters/libiconv";
	} else {
		for my $suf (@{$state->{warn_suffix}}) {
			if ($s =~ m/\Q$suf\E$/) {
				$error = "$suf suffix";
				last;
			}
		}
	}
	print STDERR "Warning: ", $p->nlist->pkgname, 
	    " contains $s ($error ?)\n" if defined $error;
}

package OpenBSD::PackingElement::Dependency;
sub process_dependency
{
	my ($self, $mtree) = @_;
	$mtree->{pkgpath}{$self->{pkgpath}} = 1;
}

package OpenBSD::PackingElement::DirlikeObject;
sub process_dependency
{
	my ($self, $mtree) = @_;

	$mtree->{dir}{$self->fullname} = 1;
}

sub tag_directories
{
	my ($self, $h) = @_;

	$h->{$self->fullname} = $self;
}

# dir-like objects HAVE a / added at the end...
package OpenBSD::PackingElement::DirBase;
sub bookmark
{
	my ($self, $plist) = @_;
	$plist->{state}{lastobject} = $self;
	$plist->{state}{lastdir} = $self;
}

package OpenBSD::PackingElement::Meta;
sub copy_annotations
{
	my ($self, $plist) = @_;
	$self->{found} = 1;
	$self->clone->add_object($plist);
}

package OpenBSD::PackingElement::UniqueOption;

package OpenBSD::PackingElement::CVSTag;
sub copy_annotations
{
	my ($self, $plist) = @_;
	$self->copy_with_tags($plist);
}

sub find_existing_cvstags
{
	my ($self, $filenames, $existing) = @_;
	$existing->{$self->{file}} = 1;
	$self->SUPER::find_existing_cvstags($filenames, $existing);
}

sub tie_objects
{
	my ($self, $plist) = @_;
	$plist->{state}{lastobject} = $self;
}

# we will never do backsubst on CVSTags
sub write_backsubst
{
	my ($o, $file, $p) = @_;
	$o->write($file->fh);
}

# these are not really in the plist on disk!
package OpenBSD::PackingElement::Name;
sub copy_annotations
{
}

sub show_unknown
{
}

package OpenBSD::PackingElement::SpecialFile;
sub copy_annotations
{
}

sub show_unknown
{
}

sub write_restate
{
}

package OpenBSD::PackingElement::ExtraInfo;
sub copy_annotations
{
}

sub show_unknown
{
}

package OpenBSD::PackingElement::Cwd;
sub show_unknown
{
}

package OpenBSD::PackingElement::Comment;
sub fullname
{
	my $self = shift;
	# let's pretend we're an object!!!
	my $path = $self->name;
	# TODO strip every keyword for matching, we may need to 
	# be more particular
	$path =~ s/^\@\w+\s+//;
	if ($path !~ m|^/|o && $self->cwd ne '.') {
		$path = $self->cwd."/".$path;
		$path =~ s,^//,/,;
	}
	$path =~ s,/$,,;
	return $path;
}

sub may_tag_along
{
	my ($self, $plist) = @_;
	$self->attach_to_lastobject($plist);
}

sub known_object
{
	&OpenBSD::PackingElement::FileObject::known_object;
}

sub cwd
{
	&OpenBSD::PackingElement::Object::cwd;
}

sub copy_annotations
{
	# nope these are not normal annotations
}

sub rebless_okay { 0 }

package OpenBSD::PackingElement::Sample;
sub may_tag_along
{
	my ($self, $plist) = @_;
	my $o = $self->{copyfrom};
	if (!defined $o) {
		print STDERR "Warning: bogus \@sample ", $self->stringize,
		    " with no reference file\n";
	} elsif (!$o->{found}) {
		print STDERR "Warning: ", $self->stringize,
		    " references a non-existing file ", $o->stringize, 
		    " and will not be copied\n";
	} else {
		$o->tag_along($self);
	}
}

sub known_object
{
}

package OpenBSD::PackingElement::Sampledir;

# this is not really smart, but good enough for starters
sub may_tag_along
{
	my ($self, $plist) = @_;
	$self->attach_to_lastobject($plist);
}

sub rebless_okay { 0 }

package OpenBSD::PackingElement::Fragment;
sub may_tag_along
{
	my ($self, $plist) = @_;
	$self->attach_to_lastobject($plist);
}

sub write_restate
{
	my ($self, $file, $p) = @_;
	$self->SUPER::write_restate($file, $p);
	my $base = $file->name;
	my $frag = $self->frag;
	$base =~ s/PFRAG\./PFRAG.$frag-/ or
	    $base =~ s/PLIST/PFRAG.$frag/;
	return $base if $p->{tracker}{known}{$base};
	return undef;
}

sub frag
{
	my $self = shift;
	return "$self->{name}";
}

package OpenBSD::PackingElement::NoFragment;
sub frag
{
	my $self = shift;
	return "no-$self->{name}";
}

package OpenBSD::PackingElement::Action;

# TODO old make-plist would check whether the substitutions didn't change
sub may_tag_along
{
	my ($self, $plist) = @_;
	# for now, we might do something smarter later
	$self->attach_to_lastobject($plist);
}

package OpenBSD::PackingElement::Unexec;
# TODO unexec's commands must be later in the plist, we should try to
# identify them
sub known_object
{
	my ($self, $exact, $approximate, $comes_after) = @_;
	for my $i (split/\s+/, $self->{expanded}) {
		next if $i eq "/usr/bin/env";
		next if $i =~ m/^\-/;
		next if $i =~ m/\=/;
		$comes_after->{$i} = $self;
	}
}

package OpenBSD::PackingElement::FileObject;
use File::Basename;

sub known_object
{
	my ($self, $exact, $approximate, $comes_after) = @_;
	my $f = $self->fullname;
	push @{$exact->{$f}}, $self;
	delete $approximate->{$f};
}

sub known_directory
{
	my ($self, $h, $plist) = @_;
	my $d = $self->fullname;
	while (1) {
		$d = dirname($d);
		# don't go up to / if we can avoid it
		return if $d eq $self->cwd or $d eq '/';
		return if defined $self->{$d}{$plist};
		$h->{$d}{$plist} = $self;
	}
}

sub show_unknown
{
	my $self = shift;
	if (!$self->{found}) {
		print "Not found: ", $self->fullname, " (in ", $self->{file}, ")\n";
	}
}

sub write_restate
{
	my ($self, $f, $p) = @_;
	
	# TODO there should be some more code matching the mode to the original
	# file that was copied
	for my $k (qw(mode owner group)) {
		my $s = "\@$k";
		if (defined $self->{$k}) {
			if (defined $p->{restate}{$k}) {
				if ($p->{restate}{$k} eq $self->{$k}) {
					next;
				}
			}
			$s .= " ".$p->subst->do_backsubst($self->{$k}, undef);
		} else {
			if (!defined $p->{restate}{$k}) {
				next;
			}
		}
		$p->{restate}{$k} = $self->{$k};
		print {$f->fh} $s, "\n";
	}
	$self->write_backsubst($f, $p);
	return undef;
}

package OpenBSD::PackingElement::FileBase;
sub bookmark
{
	my ($self, $plist) = @_;
	$plist->{state}{lastobject} = $self;
	$plist->{state}{lastfile} = $self;
}

package OpenBSD::PackingElement::Shell;
sub rebless_okay { 0 }

package OpenBSD::PackingElement::Lib;
my $first_warn = 1;
sub check_lib_version
{
	my ($self, $version, $name, $v) = @_;
	if (defined $v) {
		return if $v eq $version;
		print STDERR "ERROR: version mismatch for lib: ", $name,
		    " (", $version, " vs. ", $v, ")\n";
	} else {
		if ($first_warn) {
			print STDERR "Warning: unregistered shared lib(s)\n";
			$first_warn = 0;
		}
		print STDERR "SHARED_LIBS +=\t$name ",
		    ' 'x (25-length $name), "0.0 # $version\n";
	}
}

sub write_backsubst
{
	my ($self, $f, $p) = @_;
	if ($self->name =~ m,^(.*?)lib([^\/]+)\.so\.(\d+\.\d+)$,) {
		my ($path, $name, $version) = ($1, $2, $3);
		my $k = "LIB${name}_VERSION";
		my $s = $p->subst->do_backsubst("${path}lib$name.so.", 
		    $self->{unsubst})."\$\{$k\}";
		$self->check_lib_version($version, $name, 
			$p->subst->value($k));
		print {$f->fh} "\@", $self->keyword, " ", $s, "\n";
	} else {
		$self->SUPER::write_backsubst($f, $p);
	}
}

package OpenBSD::PackingElement::Extra;
sub copy_extra
{
	my ($self, $plist) = @_;

	$self->{found} = 1;
	$self->clone->add_object($plist);
}

package UpdatePlist;
use  File::Basename;
use File::Compare;

my $state = UpdatePlist::State->new('update-plist');

sub baseplist
{
	my $n = shift;
	if (defined $state->{pkgdir}) {
		$n =~ s/\Q$state->{pkgdir}\E\///;
	}
	return $n;
}

sub add_missing_cvstags
{
	my ($list, $base) = @_;
	my $filenames = {};
	$filenames->{$base} = 1;
	my $existing = {};
	$list->find_existing_cvstags($filenames, $existing);
	for my $name (keys %$filenames) {
		next if $existing->{$name};
		my $o = OpenBSD::PackingElement::CVSTag->add($list, 
		    '$'.'OpenBSD: '.basename($name).',v$');
		$o->{file} = $name;
	}
}

sub copy_from_old
{
	my ($e, $o, $unexec) = @_;

	my $s = $e->{comesfrom};
	if ($o->element_class ne ref($e) && $e->rebless_okay) {
		bless $e, $o->element_class;
	}

	# mark it for later
	if ($e->cwd ne $s->{state}{prefix} && 
	    # XXX doesn't apply to @rcscript
	    $o->stage == 1) {
		push(@{$s->{badcwd}}, $e);
		return;
	}

	if (defined $unexec) {
		# XXX we need to unmark it so it can tag along
		delete $e->{found};
		$unexec->tag_along($e);
	} else {
		$e->copy_with_tags($s->nlist);
	}
}

sub copy_existing
{
	my ($exact, $path, $o, $comes_after) = @_;

	if ($exact->{$path}) {
		# this will be re-added to multiple paths if there are
		# multiple matching plists
		for my $e (@{$exact->{$path}}) {
			copy_from_old($e, $o, $comes_after->{$path});
		}
		return 1;
	} else {
		return 0;
	}
}

# this handles update-plist options proper, finished with --
$state->handle_options;

my @lists;
my $exact = {};
my $approximate = {};
my $comes_after = {};

if (@ARGV == 0) {
	$state->usage;
}

# we read all plists using the exact same code as pkg_create
# e.g., ARGV is all PKG_ARGS*  parameters concatenated together:
# options1 pkgname1 options2 pkgname2 ...
while (@ARGV > 0) {
	my $r = PlistReader->new;

	my $s = PlistReader::State->new('update-plist', $state);
	$r->{state} = $s;
	$s->handle_options;
	$s->{opt}{q} = 1;
	$r->{base_plists} = $s->{contents};
	push(@lists, $r);
	my $pkg = shift;

	$r->olist->set_pkgname($pkg);
	$r->nlist->set_pkgname($pkg);
	$state->say("Reading existing plist for #1", $pkg);
	$r->read_all_fragments($s, $r->olist);
	# add the cwd to new list as well!!!
	OpenBSD::PackingElement::Cwd->add($r->nlist, $s->{prefix});
	$r->add_extra_info($r->olist, $s);
# except that we also record where each object live, including directory
# locations.  As a rule, "exact" information will supersede deduced directory
# names.
	$r->olist->known_directory($approximate, $r->olist);
	$r->olist->known_object($exact, $approximate, $comes_after);
}


# XXX we assume all subpackage are under the same destdir (-B option)
my $base = $lists[0]->{state}{base};

# now we ask the file system what exists, and fill file objects according to
# that.
$state->say("Scanning #1", $base);
if ($state->{scan_as_root}) {
	$> = 0;
}
my $objects = OpenBSD::FS2->fill($base, $state->{ignored});

$> = $fake_uid if defined $fake_uid;

# First we figure out which objects will get copied.
$state->say("Figuring out tie points");
for my $path (keys %$objects) {
	my $o = $objects->{$path};
	if ($exact->{$path}) {
		for my $e (@{$exact->{$path}}) {
			$e->{found} = 1;
		}
	}
}

# THEN we attach annotations to the closest known object
# This ought to work better if files vanish
$state->say("Tieing loose objects");
for my $p (@lists) {
	$p->olist->tie_objects($p->olist);
	$p->olist->copy_annotations($p->nlist);
}

$state->say("Copying objects");
for my $i (1, 2) {
	for my $path (sort keys %$objects) {
		my $o = $objects->{$path};
		next unless $o->stage == $i;
		next if copy_existing($exact, $path, $o, $comes_after);
		my $c = $o->element_class;

		my $found = 0;
		# we didn't find it so we must create a new one
		# go up dir until we find a matching approximate dir
		my $d = $path;
		while (1) {
			$d = dirname($d);
			last if $d eq '/';
			next unless exists $approximate->{$d};
			my @l = values %{$approximate->{$d}};
			# if we do, we only write non ambiguous names
			if (@l == 1) {
				my $s = $l[0]->{comesfrom};
				my $p2 = $s->strip_prefix($path);
				if ($p2 =~ m/^\// && !$c->absolute_okay) {
					# this will get caught as new element
					# TODO list of data to build inside
					# its own cwd
					last;
				}
				my $a = $c->add($s->nlist, $p2);
				# and match the file
				$a->{file} = $s->{file};
				$found = 1;
				last;
			}
		}
		next if $found;

		# last resort:
		# try all lists in order, until we find one with 
		# the right prefix
		for my $p (@lists) {
			my $p2 = $p->strip_prefix($path);
			if ($p2 =~ m|^/| && !$c->absolute_okay) {
				next;
			}
			my $a = $c->add($p->nlist, $p2);
			# and match the file
			$a->{file} = $p->{file};
			$found = 1;
			last;
		}
		next if $found;
		# TODO this is where we should figure @cwd stuff
		# though it's generally better to have distinct plists
		# for several prefixes
		print STDERR "Warning: can't put $path in any plist\n";
	}
}

# now we can handle stuff outside of cwd, if needed
for my $p (@lists) {
	my $cwd = $p->{state}{prefix};
	for my $e (@{$p->{badcwd}}) {
		if ($e->cwd ne $cwd) {
			$cwd = $e->cwd;
			OpenBSD::PackingElement::Cwd->add($p->nlist, $cwd);
		}
		$e->copy_with_tags($p->nlist);
	}
}

# so we read everything, let's figure out common directories
my $cache = {};
my $portsdir = $ENV{PORTSDIR};
for my $p (@lists) {
	$p->{directory_register} = {};
	$p->nlist->tag_directories($p->{directory_register});
}

for my $p (@lists) {
	if (%{$p->{directory_register}}) {
		$p->figure_out_dependencies($cache, $portsdir);
	}
}

# replace the cache entries from disk with cache entries from new plists
for my $p (@lists) {
	my $pkgpath = $p->olist->fullpkgpath;
	# optimisation: it's not a dependency, so we don't care
	next if !defined $cache->{$pkgpath};
	$cache->{$pkgpath} = {};
	$state->say("Stripping directories from #1 (trying harder)", $pkgpath);
	$p->nlist->process_dependency($cache->{$pkgpath});
}

# and redo the zapping all over again
for my $p (@lists) {
	if (%{$p->{directory_register}}) {
		$p->figure_out_dependencies($cache, $portsdir);
	}
}

for my $p (@lists) {
	$p->nlist->{name}{DONT} = 1;
	# CWD that we added manually... this sucks a bit!!!
	$p->nlist->{items}[0]{DONT} = 1;
	# that stuff might have cwd, so we copy it late
	$p->olist->copy_extra($p->nlist);
	for my $i (@{$p->{base_plists}}) {
		add_missing_cvstags($p->nlist, $i);
	}
	$p->nlist->bad_suffixes($p, $state);
	# TODO rework backsubst into redistribute, based on fullstring
}

# TODO   old make-plist noticed libraries with a LIB*_VERSION but no
# matching file

# let's show a quick summary of stuff we couldn't figure out
for my $p (@lists) {
	$p->olist->show_unknown($exact);
}

# switch to ports owner
if (defined $ports_gid) {
	$> = 0;
	$) = $ports_gid;
	$> = $ports_uid;
}

for my $p (@lists) {
	# default is the last content we have, thanks ruby :(
	$p->{tracker} = TrackFile->new($p->{base_plists}->[-1]);
	$p->nlist->redistribute($p);
	$p->{tracker}->write_all($p);
}

my @towrite = ();
my $cantmove = 0;

my $exitcode = 0;

# let's see if we want to update things
for my $p (@lists) {
	for my $k (sort keys %{$p->{tracker}{known}}) {
		if (-f $k) {
			if (!-f "$k.new") {
				print STDERR "No $k.new written\n";
				$exitcode = 1;
			} elsif (compare($k, "$k.new") == 0) {
				unlink("$k.new");
			} else {
				print baseplist($k), " changed";
				push(@towrite, $k);
				if (-f $k.".orig") {
					print " but ", baseplist($k), ".orig exists\n";
					$cantmove = 1;
				} else {
					print "\n";
				}
			}
		} else {
			print baseplist($k), " is new\n";
			push(@towrite, $k);
		}
	}
}

if ($cantmove) {
	exit(2);
}

for my $k (@towrite) {
	if (-f $k) {
		rename($k, "$k.orig") or 
		    die "can't rename $k to $k.orig: $!";
	}
	rename("$k.new", $k) or 
		    die "can't rename $k.new to $k: $!";
}

exit($exitcode);
