#! /usr/bin/perl
# $OpenBSD: update-plist,v 1.31 2018/04/27 18:23:43 espie Exp $
# Copyright (c) 2018 Marc Espie <espie@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use OpenBSD::PkgCreate;

my $ports1;
my ($ports_uid, $ports_gid, $fake_uid, $fake_gid);
BEGIN {
	$ports1 = $ENV{PORTSDIR} || '/usr/ports';
	# if we're root
	return if $< != 0;
	# switch id right away
	my $fake = $ENV{FAKE_TREE_OWNER};
	my $tree = $ENV{PORTS_TREE_OWNER};
	# XXX we can only end there if we're very naughty and building
	# everything as root, but not behind PORTS_PRIVSEP
	if (!defined $fake && !defined $tree) {
		print STDERR "DON'T BUILD PORTS AS ROOT!!!!!\n";
		print STDERR "(or make sure you pass env variables PORTS_TREE_OWNER and FAKE_TREE_OWNER thru doas to root)\n";
		return;
	}
	die "FAKE_TREE_OWNER not defined" unless defined $fake;
	die "PORTS_TREE_OWNER not defined" unless defined $tree;

	($fake_uid, $fake_gid) = (getpwnam $fake)[2,3];
	($ports_uid, $ports_gid) = (getpwnam $tree)[2,3];
	die "User $fake not found" unless defined $fake_uid;
	die "User $tree not found" unless defined $ports_uid;
	$) = $fake_gid;
	$> = $fake_uid;
}
use lib "$ports1/infrastructure/lib";

# A small package that can switch files when needed
# used by the writer that writes fragments
package TrackFile;

sub new
{
	my ($class, $default) = @_;
	my $o = bless {known => {}}, $class;
	$o->{default} = $o->open($default);
	return $o;
}

sub open
{
	my ($self, $name) = @_;
	if (!$self->{known}{$name}) {
		my $full = $name.".new";
		open(my $fh, '>', $full) or die "Can't open $full: $!";
		$self->{known}{$name} = $fh;
	}
	return $self->{known}{$name};
}

sub finish
{
	my $self = shift;
	for my $fh (values %{$self->{known}}) {
		close($fh);
	}
}

sub default
{
	my $self = shift;
	return $self->{default};
}


package Forwarder;
# perfect forwarding
sub AUTOLOAD
{
	our $AUTOLOAD;
	my $fullsub = $AUTOLOAD;
	(my $sub = $fullsub) =~ s/.*:://o;
	return if $sub eq 'DESTROY'; # special case
	no strict "refs";
	*$fullsub = sub {
		my $self = shift;
		$self->{delegate}->$sub(@_);
	};
	goto &$fullsub;
}

package ReverseSubst;
our @ISA = qw(Forwarder);
sub new
{
	bless {delegate => OpenBSD::Subst->new, used => {}, l => []}, shift;
}

my $ignore = {
	COMMENT => 1,
	MAINTAINER => 1,
	PERMIT_PACKAGE_CDROM => 1,
	PERMIT_PACKAGE_FTP => 1,
	HOMEPAGE => 1,
	REVISION => 1,
	EPOCH => 1,
};

my $special = {
	FULLPKGNAME => 1,
	MACHINE_ARCH => 1,
	ARCH => 1,
};


sub add
{
	my ($self, $k, $v) = @_;
	# XXX whatever is before FLAVORS is internal pkg_create options
	# so ignore them
	if ($k eq 'FLAVORS') {
		$self->{l} = [];
	}
	if ($ignore->{$k} || $k =~ m/^LIB\S+_VERSION$/) {
	} else {
		unshift(@{$self->{l}}, $k);
	}
	$self->{delegate}->add($k, $v);
}

sub value
{
	my ($self, $k) = @_;
	$k =~ s/\^//;
	return $self->{delegate}->value($k);
}

sub never_add
{
	my ($subst, $k) = @_;
	return $special->{$k};
}

# this has to call self's add in order for reverse_subst to work properly
sub parse_option
{
	&OpenBSD::Subst::parse_option;
}

sub do_backsubst
{
	my ($subst, $string, $self) = @_;
	for my $k (sort {$subst->value($b) cmp $subst->value($a)} @{$subst->{l}}) {
		# don't add subst on THOSE variables
		if ($subst->never_add($k)) {
			next unless defined $self->{unsubst} &&
			    $self->{unsubst} =~ m/\$\{\Q$k\E\}/;
		}
		# Heuristics: if the variable is already known AND was 
		# not used already, then we don't try to use it
		next if defined $self->{unsubst} &&
		    $subst->{used}{$k} &&
		    $self->{unsubst} !~ m/\$\{\Q$k\E\}/;
		    	
		if ($k =~ m/^\^(.*)$/) {
			my $k2 = $1;
			my $v = $subst->value($k2);
			next if $v eq '';
			$string =~ s/^\Q$v\E/\$\{\Q$k2\E\}/g;
		} else {
			my $v = $subst->value($k);
			next if $v eq '';
			$string =~ s/\Q$v\E/\$\{\Q$k\E\}/g;
		}
	}
	return $string;
}

package PlistReader;
our @ISA = qw(OpenBSD::PkgCreate);

# this is where the magic happens:
# e is the plist element
# self is the reader (with pkgname et al)
# file is the fileclass where this comes from
# unsubst is the full name before substitution
sub annotate
{
	my ($self, $e, $s, $file) = @_;
	$e->{unsubst} = $s;
	$e->{file} = $file;
	$e->{comesfrom} = $self;

	# so we redo what subst does, but we mark it!

	return $s unless $s =~ m/\$/o;	# optimization
	my $subst = $self->{state}{subst};
	while ( my $k = ($s =~ m/\$\{([A-Za-z_][^\}]*)\}/o)[0] ) {
		my $v = $subst->value($k);
		$subst->{used}{$k} = 1;
		unless ( defined $v ) { $v = "\$\\\{$k\}"; }
		$s =~ s/\$\{\Q$k\E\}/$v/g;
	}
}

# okay, so that plist doesn't exist, wouhou, I don't care,
# since I'm not pkg_create
sub cant_read_fragment
{
}

sub missing_fragments
{
}

sub new
{
	my $class = shift;
	bless { olist => OpenBSD::PackingList->new,
		nlist => OpenBSD::PackingList->new }, $class;
}

sub olist
{
	my $self = shift;
	return $self->{olist};
}

sub nlist
{
	my $self = shift;
	return $self->{nlist};
}

sub strip_prefix
{
	my ($self, $path) = @_;
	$path =~ s,^\Q$self->{state}{prefix}\E/,,;
	return $path;
}

package PlistReader::State;
our @ISA = qw(OpenBSD::PkgCreate::State);

sub init
{
	my ($self, $realstate) = @_;
	$self->{subst} = ReverseSubst->new;
	$self->{progressmeter} = $realstate->{progressmeter};
	$self->{bad} = 0;
	$self->{repo} = $realstate->{repo};
}

package UpdatePlist::State;
our @ISA = qw(OpenBSD::AddCreateDelete::State);
sub handle_options
{
	my $state = shift;
	$state->{opt} = {
		'X' => sub {
			my $path = shift;
			$state->{ignored}{$path} = 1;
		    },
	};
	$state->SUPER::handle_options('X:P:', 
	    '[mnx] [-P pkgdir] [-X path] -- pkg_create_args ...');
    	$state->{pkgdir} = $state->opt('P');
}

# copy_extra: stuff that can't be easily deduced but should be copied
package OpenBSD::PackingElement;
sub known_object
{
}

sub add_to_mtree
{
}

sub known_directory
{
}

sub show_unknown
{
}

sub copy_annotations
{
}

sub perform_backsubst
{
}

sub write_with_frags
{
	my ($o, $t) = @_;
	if (defined $o->{file}) {
		$o->write($t->open($o->{file}->name))
	} else {
		$o->write($t->default);
	}
}

sub copy_extra
{
}

# objects are (mostly) stuff with paths that can get substs...
package OpenBSD::PackingElement::Object;
sub perform_backsubst
{
	my ($self, $s) = @_;

	$self->{name} = $s->do_backsubst($self->{name}, $self);

}

package OpenBSD::PackingElement::DirlikeObject;
sub add_to_mtree
{
	my ($self, $mtree) = @_;

	$mtree->{$self->fullname} = 1;
}

# dir-like objects HAVE a / added at the end...
package OpenBSD::PackingElement::DirBase;
sub perform_backsubst
{
	my ($self, $s) = @_;

	$self->{name} = $s->do_backsubst($self->{name}.'/', $self);
	$self->{name} =~ s/\/$//;
}

package OpenBSD::PackingElement::Meta;
sub copy_annotations
{
	my ($self, $plist) = @_;
	$self->clone->add_object($plist);
}

sub perform_backsubst
{
	&OpenBSD::PackingElement::Object::perform_backsubst;
}

package OpenBSD::PackingElement::UniqueOption;
sub perform_backsubst
{
}

package OpenBSD::PackingElement::CVSTag;
sub copy_annotations
{
	my ($self, $plist) = @_;
	$self->clone->add_object($plist);
}

package OpenBSD::PackingElement::NewAuth;
sub copy_annotations
{
	&OpenBSD::PackingElement::Meta::copy_annotations;
}

# these are not really in the plist on disk!
package OpenBSD::PackingElement::Name;
sub copy_annotations
{
}

package OpenBSD::PackingElement::SpecialFile;
sub copy_annotations
{
}

package OpenBSD::PackingElement::ExtraInfo;
sub copy_annotations
{
}

package OpenBSD::PackingElement::Comment;
sub fullname
{
	my $self = shift;
	# let's pretend we're an object!!!
	my $path = $self->name;
	if ($path !~ m|^/|o && $self->cwd ne '.') {
		$path = $self->cwd."/".$path;
		$path =~ s,^//,/,;
	}
	return $path;
}

sub known_object
{
	&OpenBSD::PackingElement::FileObject::known_object;
}

sub cwd
{
	&OpenBSD::PackingElement::Object::cwd;
}

sub copy_annotations
{
	# nope these are not normal annotations
}

package OpenBSD::PackingElement::FileObject;
use File::Basename;

sub known_object
{
	my ($self, $h, $ap) = @_;
	my $f = $self->fullname;
	push @{$h->{$f}}, $self;
	delete $ap->{$f};
}

sub known_directory
{
	my ($self, $h, $plist) = @_;
	my $d = $self->fullname;
	while (1) {
		$d = dirname($d);
		# don't go up to / if we can avoid it
		return if $d eq $self->cwd or $d eq '/';
		return if defined $self->{$d}{$plist};
		$h->{$d}{$plist} = $self;
	}
}

sub show_unknown
{
	my $self = shift;
	if (!$self->{found}) {
		print "Not found: ", $self->fullname, "(in ", $self->{file}->name, ")\n";
	}
}

package OpenBSD::PackingElement::Lib;
sub perform_backsubst
{
	my ($self, $s) = @_;
	if ($self->name =~ m,^(.*)lib([^\/]+)\.so\.(\d+)\.(\d+)$,) {
		$self->{name} = $s->do_backsubst("$1lib$2.so.", $self).
		    "\$\{LIB$2_VERSION\}";
	} else {
		$self->SUPER::perform_backsubst($s);
	}
}

package OpenBSD::PackingElement::Extra;
sub copy_extra
{
	my ($self, $plist) = @_;

	if ($self->name !~ /^\// && $self->cwd ne $plist->{state}->cwd) {
	    OpenBSD::PackingElement::Cwd->add($plist, $self->cwd);
	}
	$self->{found} = 1;
	$self->clone->add_object($plist);
}

package UpdatePlist;
use  File::Basename;
use File::Compare;

my $state = UpdatePlist::State->new('update-plist');

sub baseplist
{
	my $n = shift;
	if (defined $state->{pkgdir}) {
		$n =~ s/\Q$state->{pkgdir}\E\///;
	}
	return $n;
}

sub augment_mtree
{
	my ($mtree, $fh) = @_;
	my $plist = OpenBSD::PackingList->read($fh, 
	    \&OpenBSD::PackingList::SharedItemsOnly)
	    or die "couldn't read packing-list\n";
	$plist->add_to_mtree($mtree);
}

# this handles update-plist options proper, finished with --
$state->handle_options;

my @lists;
my $exact = {};
my $approximate = {};

# we read all plists using the exact same code as pkg_create
# e.g., ARGV is all PKG_ARGS*  parameters concatenated together:
# options1 pkgname1 options2 pkgname2 ...
while (@ARGV > 0) {
	my $r = PlistReader->new;

	my $s = PlistReader::State->new('update-plist', $state);
	$r->{state} = $s;
	$s->handle_options;
	$s->{opt}{q} = 1;
	die "bad arguments to update-plist" if @{$s->{contents}} != 1;
	$r->{base_plistname} = $s->{contents}->[0];
	push(@lists, $r);
	my $pkg = shift;

	$r->olist->set_pkgname($pkg);
	$r->nlist->set_pkgname($pkg);
	$r->read_all_fragments($s, $r->olist);
	$r->add_extra_info($r->olist, $s);
	# for removing directory stuff later on
# except that we also record where each object live, including directory
# locations.  As a rule, "exact" information will supersede deduced directory
# names.
	$r->olist->known_directory($approximate, $r->olist);
	$r->olist->known_object($exact, $approximate);
	$state->say("Processed #1 as #2", $pkg, $r->olist->fullpkgpath);
}

my $make = $ENV{MAKE};
my $portsdir = $ENV{PORTSDIR};
my $portsdir_path = $ENV{PORTSDIR_PATH};
my $cached_tree = {};

# so we read everything, let's figure out common directories
#for my $p (@lists) {
#	for my $full (keys %{$p->{state}{dependencies}}) {
#		next unless $full =~ m/^(.*)?:/;
#		my $pkgpath = $1;
#		$state->say("Dependency on #1", $pkgpath);
#		if (!defined $cached_tree->{$pkgpath}) {
#			$cached_tree->{$pkgpath} = {};
#			open my $fh, "cd $portsdir && env -i PORTSDIR_PATH=$portsdir_path SUBDIR=$pkgpath ECHO_MSG=: $make print-plist |" or die "blech\n";
#			augment_mtree($cached_tree->{$pkgpath}, $fh);
#			close($fh);
#		}
#	}
#}


# XXX we assume all subpackage are under the same destdir (-B option)
my $base = $lists[0]->{state}{base};

# now we ask the file system what exists, and fill file objects according to
# that.
require OpenBSD::FS2;
$state->say("Scanning #1", $base);
my $objects = OpenBSD::FS2->fill($base, $state->{ignored});

$state->say("Matching objects");

# once we figured out existing object, we try to preserve @exec and similar
# info as best as we can.

#for my $s (@$states) {
#	$s->plist->tie_objects;
#}

$state->say("Copying objects");
for my $i (1, 2) {
	for my $path (sort keys %$objects) {
		my $o = $objects->{$path};
		next unless $o->stage == $i;
		if ($exact->{$path}) {
			# this will be re-added to multiple paths if there are
			# multiple matching plists
			for my $e (@{$exact->{$path}}) {
				$e->{found} = 1;
				my $s = $e->{comesfrom};
				$e->add_object($s->nlist);
			}
			next;
		}

		# we didn't find it so we must create a new one
		# go up dir until we find a matching approximate dir
		my $d = $path;
		while (1) {
			$d = dirname($d);
			last if $d eq '/';
			next unless exists $approximate->{$d};
			my @l = values %{$approximate->{$d}};
			# if we do, we only write non ambiguous names
			if (@l == 1) {
				my $s = $l[0]->{comesfrom};
				my $a =$o->element_class->add($s->nlist, 
				    $s->strip_prefix($path));
				# and match the file
				$a->{file} = $s->{file};
				last;
			}
		}
		# last resort
		$o->element_class->add($lists[0]->nlist, 
		    $lists[0]->strip_prefix($path));
	}
}

for my $p (@lists) {
	delete $p->nlist->{name};
	$p->olist->copy_annotations($p->nlist);
	# that stuff might have cwd, so we copy it late
	$p->olist->copy_extra($p->nlist);
}

for my $p (@lists) {
	$p->nlist->perform_backsubst($p->{state}{subst});
}


# let's show a quick summary of stuff we couldn't figure out
for my $p (@lists) {
	$p->olist->show_unknown($exact);
}

# switch to ports owner
$> = 0;
$) = $ports_gid;
$> = $ports_uid;

for my $p (@lists) {
	$p->{tracker} = TrackFile->new($p->{base_plistname});
	$p->nlist->write_with_frags($p->{tracker});
	$p->{tracker}->finish;
}

my @towrite = ();
my $cantmove = 0;

# let's see if we want to update things
for my $p (@lists) {
	for my $k (sort keys %{$p->{tracker}{known}}) {
		if (-f $k) {
			if (compare($k, "$k.new") == 0) {
				unlink("$k.new");
			} else {
				print baseplist($k), " changed";
				push(@towrite, $k);
				if (-f $k.".orig") {
					print " but ", baseplist($k), ".orig exists\n";
					$cantmove = 1;
				} else {
					print "\n";
				}
			}
		} else {
			print baseplist($k), "is new\n";
			push(@towrite, $k);
		}
	}
}

if (@towrite > 0 && !$cantmove) {
	for my $k (@towrite) {
		if (-f $k) {
			rename($k, "$k.orig") or 
			    die "can't rename $k to $k.orig: $!";
		}
		rename("$k.new", $k) or 
			    die "can't rename $k.new to $k: $!";
	}
}

