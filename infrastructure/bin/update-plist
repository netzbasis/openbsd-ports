#! /usr/bin/perl
# $OpenBSD: update-plist,v 1.73 2018/05/02 14:44:00 espie Exp $
# Copyright (c) 2018 Marc Espie <espie@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use OpenBSD::PkgCreate;

my $ports1;
my ($ports_uid, $ports_gid, $fake_uid, $fake_gid);
BEGIN {
	$ports1 = $ENV{PORTSDIR} || '/usr/ports';
	# if we're root
	return if $< != 0;
	# switch id right away
	my $fake = $ENV{FAKE_TREE_OWNER};
	my $tree = $ENV{PORTS_TREE_OWNER};
	# XXX we can only end there if we're very naughty and building
	# everything as root, but not behind PORTS_PRIVSEP
	if (!defined $fake && !defined $tree) {
		print STDERR "DON'T BUILD PORTS AS ROOT!!!!!\n";
		print STDERR "(or make sure you pass env variables PORTS_TREE_OWNER and FAKE_TREE_OWNER thru doas to root)\n";
		return;
	}
	die "FAKE_TREE_OWNER not defined" unless defined $fake;
	die "PORTS_TREE_OWNER not defined" unless defined $tree;

	($fake_uid, $fake_gid) = (getpwnam $fake)[2,3];
	($ports_uid, $ports_gid) = (getpwnam $tree)[2,3];
	die "User $fake not found" unless defined $fake_uid;
	die "User $tree not found" unless defined $ports_uid;
	$) = $fake_gid;
	$> = $fake_uid;
}
use lib "$ports1/infrastructure/lib";

package TrackedFile;
sub new
{
	my ($class, $name) = @_;
	bless {name => $name, items => []}, $class;
}

sub add
{
	my ($self, $item) = @_;
	push(@{$self->{items}}, $item);
}

sub fh
{
	my $self = shift;
	if (!defined $self->{fh}) {
		my $full = $self->name.".new";
		open($self->{fh}, '>', $full) or die "Can't open $full: $!";
	}
	return $self->{fh};
}

sub name
{
	my $self = shift;
	return $self->{name};
}

sub next_item
{
	my $self = shift;
	if (@{$self->{items}} != 0) {
		return shift @{$self->{items}};
	} else {
		return undef;
	}
}

package TrackFile;

sub new
{
	my ($class, $default) = @_;
	my $self = bless {}, $class;
	$self->{known}{$default} = 
	    $self->{default} = TrackedFile->new($default);
	return $self;
}

sub file
{
	my ($self, $name) = @_;
	$self->{known}{$name} //= TrackedFile->new($name);
	return $self->{known}{$name};
}

sub default
{
	my $self = shift;
	return $self->{default};
}

sub write_all
{
	my ($self, $p) = @_;

	# we mimic the way pkg_create writes files
	$p->{restate} = {};

	my @stack = ();
	push(@stack, $self->default);


	while (my $file = pop @stack) {
		while (my $i = $file->next_item) {
			my $filename = $i->write_restate($file, $p);
			if (defined $filename) {
				push(@stack, $file);
				$file = $self->file($filename);
			}
		}
		close($file->fh);
	}

	# TODO we should check we got them all
}

package Forwarder;
# perfect forwarding
sub AUTOLOAD
{
	our $AUTOLOAD;
	my $fullsub = $AUTOLOAD;
	(my $sub = $fullsub) =~ s/.*:://o;
	return if $sub eq 'DESTROY'; # special case
	no strict "refs";
	*$fullsub = sub {
		my $self = shift;
		$self->{delegate}->$sub(@_);
	};
	goto &$fullsub;
}

package ReverseSubst;
our @ISA = qw(Forwarder);
sub new
{
	bless {delegate => OpenBSD::Subst->new, 
	    # count the number of times we see each value. More than once,
	    # hard to figure out WHICH one to backsubst
	    count => {}, 
	    # record that a variable is actually used. Then if we see the
	    # string and no backsubst, it's probably intentional
	    used => {}, 
	    # list of actual variables we care about, e.g., ignored stuff
	    # and whatnot
	    l => []}, shift;
}

my $ignore = {
	COMMENT => 1,
	MAINTAINER => 1,
	PERMIT_PACKAGE_CDROM => 1,
	PERMIT_PACKAGE_FTP => 1,
	HOMEPAGE => 1,
	REVISION => 1,
	EPOCH => 1,
};

my $special = {
	FULLPKGNAME => 1,
	FULLPKGPATH => 1,
	MACHINE_ARCH => 1,
	ARCH => 1,
	BASE_PKGPATH => 1,
};


sub add
{
	my ($self, $k, $v) = @_;
	# XXX whatever is before FLAVORS is internal pkg_create options
	# so ignore them
	if ($k eq 'FLAVORS') {
		$self->{l} = [];
		$self->{count} = {};
	}
	if ($ignore->{$k} || $k =~ m/^LIB\S+_VERSION$/) {
	} else {
		unshift(@{$self->{l}}, $k);
		$self->{count}{$v}++;
	}
	$self->{delegate}->add($k, $v);
}

sub value
{
	my ($self, $k) = @_;
	$k =~ s/\^//;
	return $self->{delegate}->value($k);
}

sub never_add
{
	my ($self, $k) = @_;
	if ($self->{count}{$self->value($k)} > 1) {
		return 1;
	} else {
		return $special->{$k};
	}
}

# this has to call self's add in order for reverse_subst to work properly
sub parse_option
{
	&OpenBSD::Subst::parse_option;
}

sub do_backsubst
{
	my ($subst, $string, $unsubst) = @_;
	for my $k (sort {$subst->value($b) cmp $subst->value($a)} @{$subst->{l}}) {
		my $k2 = $k;
		$k2 =~ s/^\^//;
		# don't add subst on THOSE variables
		# TODO ARCH, MACHINE_ARCH could happen, but only with word
		#  boundary contexts
		if ($subst->never_add($k2)) {
			unless (defined $unsubst &&
			    $unsubst =~ m/\$\{\Q$k2\E\}/) {
			    	# add a magical location for FULLPKGNAME
			    	next unless $k2 eq 'FULLPKGNAME' &&
				    $string =~ m,^share/doc/pkg-readmes/,;
			}
		} else {
			# Heuristics: if the variable is already known AND was 
			# not used already, then we don't try to use it
			next if defined $unsubst &&
			    $subst->{used}{$k2} &&
			    $unsubst !~ m/\$\{$k2\}/;
		}
		    	
		if ($k =~ m/^\^(.*)$/) {
			my $v = $subst->value($k2);
			# Empty variable at start of string
			# if it was already there we do it again
			if ($v eq '') {
				if (defined $unsubst &&
				    $unsubst =~ m/^\$\{$k2\}/) {
				    	$string =~ s/^/\$\{$k2\}/;
				}
			} else {
				$string =~ s/^\Q$v\E/\$\{$k2\}/;
			}
		} else {
			# TODO on the other hand, numeric and version-like
			# variables shouldn't substitute partial numbers
			my $v = $subst->value($k);
			# Empty variable somewhere in the string
			# if it was already there, we try to locate
			# the same prefix and apply it
			if ($v eq '') {
				if (defined $unsubst &&
				    $unsubst =~ m/^(.*)\$\{$k2\}/) {
				    	my $prefix = $1;
					# XXX hack around @keyword
					$prefix =~ s/^\@\S+\s+//;
				    	$string =~ s/\Q$prefix\E/$prefix\$\{$k2\}/;
				}
			} else {
				$string =~ s/\Q$v\E/\$\{$k2\}/g;
			}
		}
	}
	return $string;
}

package PlistReader;
our @ISA = qw(OpenBSD::PkgCreate);

# this is where the magic happens:
# e is the plist element
# self is the reader (with pkgname et al)
# file is the fileclass where this comes from
# unsubst is the full name before substitution
sub annotate
{
	my ($self, $e, $s, $file) = @_;
	$e->{unsubst} = $s;
	$e->{file} = $file->name;
	$e->{comesfrom} = $self;

	# so we redo what subst does, but we mark it!

	return unless defined $s;
	return unless $s =~ m/\$/o;	# optimization
	my $subst = $self->{state}{subst};
	while ( my $k = ($s =~ m/\$\{([A-Za-z_][^\}]*)\}/o)[0] ) {
		my $v = $subst->value($k);
		$subst->{used}{$k} = 1;
		unless ( defined $v ) { $v = "\$\\\{$k\}"; }
		$s =~ s/\$\{\Q$k\E\}/$v/g;
	}
}

# and more magic, we want to record fragments as pseudo-objects
sub record_fragment
{
	my ($self, $plist, $not, $name, $file) = @_;
	my $f;
	if ($not) {
		$f = OpenBSD::PackingElement::NoFragment->add($plist, $name);
	} else {
		$f = OpenBSD::PackingElement::Fragment->add($plist, $name);
	}
	$self->annotate($f, undef, $file);
}


# okay, so that plist doesn't exist, wouhou, I don't care,
# since I'm not pkg_create
sub cant_read_fragment
{
}

sub missing_fragments
{
}

sub new
{
	my $class = shift;
	bless { olist => OpenBSD::PackingList->new,
		nlist => OpenBSD::PackingList->new }, $class;
}

sub olist
{
	my $self = shift;
	return $self->{olist};
}

sub nlist
{
	my $self = shift;
	return $self->{nlist};
}

sub strip_prefix
{
	my ($self, $path) = @_;
	$path =~ s,^\Q$self->{state}{prefix}\E/,,;
	return $path;
}

sub figure_out_dependencies
{
	my ($self, $cache, $portsdir) = @_;
	my @solve = ();
	for my $full (keys %{$self->{state}{dependencies}}) {
		next unless $full =~ m/^(.*?):/;
		push(@solve, $1);
	}
	while (@solve != 0) {
		my $pkgpath = pop @solve;
		if (!defined $cache->{$pkgpath}) {
			$cache->{$pkgpath} = {};
			$self->{state}->say("Stripping directories from #1",
			    $pkgpath);
			my $plist = OpenBSD::Dependencies::CreateSolver->ask_tree(
			    $self->{state}, $pkgpath, $portsdir,
			    \&OpenBSD::PackingList::UpdatePlistOnly,
			    "print-plist-with-depends", "wantlib_args=no-wantlib-args");
			$plist->process_dependency($cache->{$pkgpath});
		}
		for my $dir (keys %{$cache->{$pkgpath}{dir}}) {
			$self->{stripped}{$dir} = 1;
		}
		push(@solve, keys %{$cache->{$pkgpath}{pkgpath}});
	}
}

package PlistReader::State;
our @ISA = qw(OpenBSD::PkgCreate::State);

sub init
{
	my ($self, $realstate) = @_;
	$self->{subst} = ReverseSubst->new;
	$self->{progressmeter} = $realstate->{progressmeter};
	$self->{bad} = 0;
	$self->{repo} = $realstate->{repo};
}

package UpdatePlist::State;
our @ISA = qw(OpenBSD::AddCreateDelete::State);
sub handle_options
{
	my $state = shift;
	$state->{opt} = {
		'X' => sub {
			my $path = shift;
			$state->{ignored}{$path} = 1;
		    },
		'w' => sub {
			my $warn = shift;
			push(@{$state->{warn_suffix}}, $warn);
		},
	};
	$state->SUPER::handle_options('X:P:w:', 
	    '[-mnx] [-P pkgdir] [-w suffix] [-X path] -- pkg_create_args ...');
    	$state->{pkgdir} = $state->opt('P');
}

# copy_extra: stuff that can't be easily deduced but should be copied
package OpenBSD::PackingElement;
sub known_object
{
}

sub process_dependency
{
}

sub known_directory
{
}

sub show_unknown
{
}

sub copy_annotations
{
}

sub perform_backsubst
{
}

sub redistribute
{
	my ($o, $p) = @_;
	return if $o->{DONT};
	if (defined $o->{file}) {
		$p->{tracker}->file($o->{file})->add($o);
	} else {
		$p->{tracker}->default->add($o);
	}
}
sub strip_directories
{
}

sub write_restate
{
	my ($o, $file, $p) = @_;
	$o->write($file->fh);
	return undef;
}

sub copy_extra
{
}

sub tag_along
{
	my ($self, $n) = @_;

	push(@{$self->{mytags}}, $n);
}

sub tie_objects
{
	my ($self, $plist) = @_;
	if ($self->{found}) {
		$self->bookmark($plist);
	} else {
		$self->may_tag_along($plist);
	}
}

sub attach_to_lastobject
{
	my ($self, $plist) = @_;
	if (defined $plist->{state}{lastobject}) {
		$plist->{state}{lastobject}->tag_along($self);
	}
}

sub bookmark
{
}

sub may_tag_along
{
}

sub count_directories
{
}

sub bad_suffixes
{
}

sub find_existing_cvstags
{
	my ($self, $filenames, $existing) = @_;
	if (defined $self->{file}) {
		$filenames->{$self->{file}} = 1;
	}
}

# objects are (mostly) stuff with paths that can get substs...
package OpenBSD::PackingElement::Object;
sub perform_backsubst
{
	my ($self, $s) = @_;

	$self->{name} = $s->do_backsubst($self->{name}, $self->{unsubst});

}

sub bad_suffixes
{
	my ($self, $p, $state) = @_;

	# don't care if it's already in a PLIST
	return if defined $self->{comesfrom};
	my $s = $self->fullname;
	my $error;
	if ($s =~ m/\/\.[^\/]*\.swp$/) {
		$error = "vim swap file";
	} elsif ($s =~ m/\~$/) {
		$error = "emacs temporary file";
	} elsif ($s eq '/usr/local/lib/charset.alias' && 
	    $p->olist->fullpkgpath ne 'converters/libiconv') {
		$error = "file from converters/libiconv";
	} else {
		for my $suf (@{$state->{warn_suffix}}) {
			if ($s =~ m/\Q$suf\E$/) {
				$error = "$suf suffix";
				last;
			}
		}
	}
	print STDERR "Warning: ", $p->nlist->pkgname, 
	    " contains $s ($error ?)\n" if defined $error;
}

package OpenBSD::PackingElement::Dependency;
sub process_dependency
{
	my ($self, $mtree) = @_;
	$mtree->{pkgpath}{$self->{pkgpath}} = 1;
}

package OpenBSD::PackingElement::DirlikeObject;
sub process_dependency
{
	my ($self, $mtree) = @_;

	$mtree->{dir}{$self->fullname} = 1;
}

sub count_directories
{
	my ($self, $count) = @_;
	$$count++;
}

sub strip_directories
{
	my ($o, $stripped) = @_;
	if ($stripped->{$o->fullname}) {
		$o->{DONT} = 1;
	}
}

# dir-like objects HAVE a / added at the end...
package OpenBSD::PackingElement::DirBase;
sub perform_backsubst
{
	my ($self, $s) = @_;

	$self->{name} = $s->do_backsubst($self->{name}.'/', $self->{unsubst});
	$self->{name} =~ s/\/$//;
}

sub bookmark
{
	my ($self, $plist) = @_;
	$plist->{state}{lastobject} = $self;
	$plist->{state}{lastdir} = $self;
}

package OpenBSD::PackingElement::Meta;
sub copy_annotations
{
	my ($self, $plist) = @_;
	$self->clone->add_object($plist);
}

sub perform_backsubst
{
	&OpenBSD::PackingElement::Object::perform_backsubst;
}

package OpenBSD::PackingElement::UniqueOption;
sub perform_backsubst
{
}

package OpenBSD::PackingElement::CVSTag;
sub copy_annotations
{
	my ($self, $plist) = @_;
	$self->clone->add_object($plist);
}

sub find_existing_cvstags
{
	my ($self, $filenames, $existing) = @_;
	$existing->{$self->{file}} = 1;
	$self->SUPER::find_existing_cvstags($filenames, $existing);
}

package OpenBSD::PackingElement::NewAuth;
sub copy_annotations
{
	&OpenBSD::PackingElement::Meta::copy_annotations;
}

# these are not really in the plist on disk!
package OpenBSD::PackingElement::Name;
sub copy_annotations
{
}

package OpenBSD::PackingElement::SpecialFile;
sub copy_annotations
{
}

package OpenBSD::PackingElement::ExtraInfo;
sub copy_annotations
{
}

package OpenBSD::PackingElement::Comment;
sub fullname
{
	my $self = shift;
	# let's pretend we're an object!!!
	my $path = $self->name;
	# TODO strip every keyword for matching, we may need to 
	# be more particular
	$path =~ s/^\@\w+\s+//;
	if ($path !~ m|^/|o && $self->cwd ne '.') {
		$path = $self->cwd."/".$path;
		$path =~ s,^//,/,;
	}
	$path =~ s,/$,,;
	return $path;
}

sub may_tag_along
{
	my ($self, $plist) = @_;
	$self->attach_to_lastobject($plist);
}

sub known_object
{
	&OpenBSD::PackingElement::FileObject::known_object;
}

sub cwd
{
	&OpenBSD::PackingElement::Object::cwd;
}

sub copy_annotations
{
	# nope these are not normal annotations
}

package OpenBSD::PackingElement::Sample;
sub may_tag_along
{
	my ($self, $plist) = @_;
	my $o = $self->{copyfrom};
	if (!defined $o) {
		print STDERR "Warning: bogus \@sample ", $self->stringize,
		    " with no reference file\n";
	} elsif (!$o->{found}) {
		print STDERR "Warning: ", $self->stringize,
		    " references a non-existing file ", $o->stringize, 
		    " and will not be copied\n";
	} else {
		$o->tag_along($self);
	}
}

package OpenBSD::PackingElement::Sampledir;

# this is not really smart, but good enough for starters
sub may_tag_along
{
	my ($self, $plist) = @_;
	$self->attach_to_lastobject($plist);
}

package OpenBSD::PackingElement::Fragment;
sub may_tag_along
{
	my ($self, $plist) = @_;
	$self->attach_to_lastobject($plist);
}

sub write_restate
{
	my ($self, $file, $p) = @_;
	$self->SUPER::write_restate($file, $p);
	my $base = $file->name;
	my $frag = $self->frag;
	$base =~ s/PFRAG\./PFRAG.$frag-/ or
	    $base =~ s/PLIST/PFRAG.$frag/;
	return $base if $p->{tracker}{known}{$base};
	return undef;
}

sub frag
{
	my $self = shift;
	return "$self->{name}";
}

package OpenBSD::PackingElement::NoFragment;
sub frag
{
	my $self = shift;
	return "no-$self->{name}";
}

package OpenBSD::PackingElement::Action;
sub may_tag_along
{
	my ($self, $plist) = @_;
	# for now, we might do something smarter later
	$self->attach_to_lastobject($plist);
}

package OpenBSD::PackingElement::FileObject;
use File::Basename;

sub known_object
{
	my ($self, $h, $ap) = @_;
	my $f = $self->fullname;
	push @{$h->{$f}}, $self;
	delete $ap->{$f};
}

sub known_directory
{
	my ($self, $h, $plist) = @_;
	my $d = $self->fullname;
	while (1) {
		$d = dirname($d);
		# don't go up to / if we can avoid it
		return if $d eq $self->cwd or $d eq '/';
		return if defined $self->{$d}{$plist};
		$h->{$d}{$plist} = $self;
	}
}

sub show_unknown
{
	my $self = shift;
	if (!$self->{found}) {
		print "Not found: ", $self->fullname, " (in ", $self->{file}, ")\n";
	}
}

sub write_restate
{
	my ($self, $f, $p) = @_;
	
	# TODO there should be some more code matching the mode to the original
	# file that was copied
	my $fh = $f->fh;
	for my $k (qw(mode owner group)) {
		my $s = "\@$k";
		if (defined $self->{$k}) {
			if (defined $p->{restate}{$k}) {
				if ($p->{restate}{$k} eq $self->{$k}) {
					next;
				}
			}
			$s .= " ".$p->{state}{subst}->do_backsubst($self->{$k}, undef);
		} else {
			if (!defined $p->{restate}{$k}) {
				next;
			}
		}
		$p->{restate}{$k} = $self->{$k};
		print $fh $s, "\n";
	}
	$self->write($fh);
	return undef;
}

package OpenBSD::PackingElement::FileBase;
sub bookmark
{
	my ($self, $plist) = @_;
	$plist->{state}{lastobject} = $self;
	$plist->{state}{lastfile} = $self;
}

package OpenBSD::PackingElement::Lib;
sub perform_backsubst
{
	my ($self, $s) = @_;
	if ($self->name =~ m,^(.*?)lib([^\/]+)\.so\.(\d+)\.(\d+)$,) {
		$self->{name} = $s->do_backsubst("$1lib$2.so.", 
		    $self->{unsubst})."\$\{LIB$2_VERSION\}";
	} else {
		$self->SUPER::perform_backsubst($s);
	}
}

package OpenBSD::PackingElement::Extra;
sub copy_extra
{
	my ($self, $plist) = @_;

	if ($self->name !~ /^\// && $self->cwd ne $plist->{state}->cwd) {
	    OpenBSD::PackingElement::Cwd->add($plist, $self->cwd);
	}
	$self->{found} = 1;
	$self->clone->add_object($plist);
}

package UpdatePlist;
use  File::Basename;
use File::Compare;

my $state = UpdatePlist::State->new('update-plist');

sub baseplist
{
	my $n = shift;
	if (defined $state->{pkgdir}) {
		$n =~ s/\Q$state->{pkgdir}\E\///;
	}
	return $n;
}

sub add_missing_cvstags
{
	my ($list, $base) = @_;
	my $filenames = {};
	$filenames->{$base} = 1;
	my $existing = {};
	$list->find_existing_cvstags($filenames, $existing);
	for my $name (keys %$filenames) {
		next if $existing->{$name};
		my $o = OpenBSD::PackingElement::CVSTag->add($list, 
		    '$'.'OpenBSD'.'$');
		$o->{file} = $name;
	}
}

use UNIVERSAL;

sub copy_from_old
{
	my ($e, $o) = @_;

	my $s = $e->{comesfrom};
	my $rebless = 0;
	if ($o->element_class ne ref($e)) {
		$rebless = 1;
		# XXX do not touch commented out data
		if ($e->isa("OpenBSD::PackingElement::Comment")) {
			$rebless = 0;
		# TODO and do not touch directory classes, we don't know
		# enough from FS2 yet
		} elsif ($e->isa("OpenBSD::PackingElement::DirlikeObject")
		    && $o->element_class eq 'OpenBSD::PackingElement::Dir') {
			$rebless = 0;
		}
	}
	# XXX this should be safe for all our objects
	bless $e, $o->element_class if $rebless;

	$e->add_object($s->nlist);
	if (defined $e->{mytags}) {
		for my $tag (@{$e->{mytags}}) {
			$tag->add_object($s->nlist);
			$tag->{found} = 1;
		}
	}
}

sub copy_existing
{
	my ($exact, $path, $o) = @_;

	if ($exact->{$path}) {
		# this will be re-added to multiple paths if there are
		# multiple matching plists
		for my $e (@{$exact->{$path}}) {
			copy_from_old($e, $o);
		}
		return 1;
	} else {
		return 0;
	}
}

# this handles update-plist options proper, finished with --
$state->handle_options;

my @lists;
my $exact = {};
my $approximate = {};

if (@ARGV == 0) {
	$state->usage;
}

# we read all plists using the exact same code as pkg_create
# e.g., ARGV is all PKG_ARGS*  parameters concatenated together:
# options1 pkgname1 options2 pkgname2 ...
while (@ARGV > 0) {
	my $r = PlistReader->new;

	my $s = PlistReader::State->new('update-plist', $state);
	$r->{state} = $s;
	$s->handle_options;
	$s->{opt}{q} = 1;
	die "bad arguments to update-plist" if @{$s->{contents}} != 1;
	$r->{base_plistname} = $s->{contents}->[0];
	push(@lists, $r);
	my $pkg = shift;

	$r->olist->set_pkgname($pkg);
	$r->nlist->set_pkgname($pkg);
	$state->say("Reading existing plist for #1", $pkg);
	$r->read_all_fragments($s, $r->olist);
	# add the cwd to new list as well!!!
	OpenBSD::PackingElement::Cwd->add($r->nlist, $s->{prefix});
	$r->add_extra_info($r->olist, $s);
	# for removing directory stuff later on
# except that we also record where each object live, including directory
# locations.  As a rule, "exact" information will supersede deduced directory
# names.
	$r->olist->known_directory($approximate, $r->olist);
	$r->olist->known_object($exact, $approximate);
}


# XXX we assume all subpackage are under the same destdir (-B option)
my $base = $lists[0]->{state}{base};

# now we ask the file system what exists, and fill file objects according to
# that.
require OpenBSD::FS2;
$state->say("Scanning #1", $base);
my $objects = OpenBSD::FS2->fill($base, $state->{ignored});


# First we figure out which objects will get copied.
$state->say("Figuring out tie points");
for my $path (keys %$objects) {
	my $o = $objects->{$path};
	if ($exact->{$path}) {
		for my $e (@{$exact->{$path}}) {
			$e->{found} = 1;
		}
	}
}

# THEN we attach annotations to the closest known object
# This ought to work better if files vanish
$state->say("Tieing loose objects");
for my $p (@lists) {
	$p->olist->tie_objects($p->olist);
}

$state->say("Copying objects");
for my $i (1, 2) {
	for my $path (sort keys %$objects) {
		my $o = $objects->{$path};
		next unless $o->stage == $i;
		next if copy_existing($exact, $path, $o);
		my $c = $o->element_class;

		my $found = 0;
		# we didn't find it so we must create a new one
		# go up dir until we find a matching approximate dir
		my $d = $path;
		while (1) {
			$d = dirname($d);
			last if $d eq '/';
			next unless exists $approximate->{$d};
			my @l = values %{$approximate->{$d}};
			# if we do, we only write non ambiguous names
			if (@l == 1) {
				my $s = $l[0]->{comesfrom};
				my $p2 = $s->strip_prefix($path);
				my $a = $c->add($s->nlist, $p2);
				# and match the file
				$a->{file} = $s->{file};
				$found = 1;
				last;
			}
		}
		next if $found;

		# last resort:
		# try all lists in order, until we find one with 
		# the right prefix
		for my $p (@lists) {
			my $p2 = $p->strip_prefix($path);
			if ($p2 =~ m|^/| && !$c->absolute_okay) {
				next;
			}
			my $a = $c->add($p->nlist, $p2);
			# and match the file
			$a->{file} = $p->{file};
			$found = 1;
			last;
		}
		next if $found;
		# TODO this is where we should figure @cwd stuff
		# though it's generally better to have distinct plists
		# for several prefixes
		print STDERR "Warning: can't put $path in any plist\n";
	}
}

# so we read everything, let's figure out common directories
my $cache = {};
my $portsdir = $ENV{PORTSDIR};
for my $p (@lists) {
	my $count = 0;
	$p->nlist->count_directories(\$count);
	$p->{count_directories} = $count;
}

for my $p (@lists) {
	if ($p->{count_directories} > 0) {
		$p->figure_out_dependencies($cache, $portsdir);
	}
}

# replace the cache entries from disk with cache entries from new plists
for my $p (@lists) {
	my $pkgpath = $p->olist->fullpkgpath;
	# optimisation: it's not a dependency, so we don't care
	next if !defined $cache->{$pkgpath};
	$cache->{$pkgpath} = {};
	$state->say("Stripping directories from #1 (trying harder)", $pkgpath);
	$p->nlist->process_dependency($cache->{$pkgpath});
}

# and redo the zapping all over again
for my $p (@lists) {
	if ($p->{count_directories} > 0) {
		$p->figure_out_dependencies($cache, $portsdir);
	}
}

for my $p (@lists) {
	$p->nlist->{name}{DONT} = 1;
	# CWD that we added manually... this sucks a bit!!!
	$p->nlist->{items}[0]{DONT} = 1;
	$p->olist->copy_annotations($p->nlist);
	# that stuff might have cwd, so we copy it late
	$p->olist->copy_extra($p->nlist);
	add_missing_cvstags($p->nlist, $p->{base_plistname});
	$p->nlist->bad_suffixes($p, $state);
	# XXX this has to happen *before* backsubst
	$p->nlist->strip_directories($p->{stripped});
	$p->nlist->perform_backsubst($p->{state}{subst});
}

# let's show a quick summary of stuff we couldn't figure out
for my $p (@lists) {
	$p->olist->show_unknown($exact);
}

# switch to ports owner
$> = 0;
$) = $ports_gid;
$> = $ports_uid;

for my $p (@lists) {
	$p->{tracker} = TrackFile->new($p->{base_plistname});
	$p->nlist->redistribute($p);
	$p->{tracker}->write_all($p);
}

my @towrite = ();
my $cantmove = 0;

# let's see if we want to update things
for my $p (@lists) {
	for my $k (sort keys %{$p->{tracker}{known}}) {
		if (-f $k) {
			if (compare($k, "$k.new") == 0) {
				unlink("$k.new");
			} else {
				print baseplist($k), " changed";
				push(@towrite, $k);
				if (-f $k.".orig") {
					print " but ", baseplist($k), ".orig exists\n";
					$cantmove = 1;
				} else {
					print "\n";
				}
			}
		} else {
			print baseplist($k), " is new\n";
			push(@towrite, $k);
		}
	}
}

if (@towrite > 0 && !$cantmove) {
	for my $k (@towrite) {
		if (-f $k) {
			rename($k, "$k.orig") or 
			    die "can't rename $k to $k.orig: $!";
		}
		rename("$k.new", $k) or 
			    die "can't rename $k.new to $k: $!";
	}
}
