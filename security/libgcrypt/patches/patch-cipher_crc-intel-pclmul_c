$OpenBSD: patch-cipher_crc-intel-pclmul_c,v 1.3 2016/05/08 23:21:29 jca Exp $

1. disable plcmul (actually SSE4.1) for CRC, asm instructions unknown to base gcc
  "crc-intel-pclmul.c:369: Error: no such instruction: `pextrd $1,%xmm0,(%rdi)'"

2.
From: Werner Koch <wk@gnupg.org>
Date: Tue, 19 Apr 2016 18:05:07 +0000 (+0200)
Subject: asm fix for older gcc versions.
X-Git-Url: http://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commitdiff_plain;h=4545372c0f8dd35aef2a7abc12b588ed1a4a0363;hp=eecc081f8ae02c43454abaee4a4f72efaee42745
asm fix for older gcc versions.

--- cipher/crc-intel-pclmul.c.orig	Thu Apr  7 17:30:08 2016
+++ cipher/crc-intel-pclmul.c	Sun May  8 18:56:35 2016
@@ -30,7 +30,7 @@
 #include "bufhelp.h"
 
 
-#if defined(ENABLE_PCLMUL_SUPPORT) && __GNUC__ >= 4 && \
+#if 0 && __GNUC__ >= 4 && \
     ((defined(__i386__) && SIZEOF_UNSIGNED_LONG == 4) || defined(__x86_64__))
 
 
@@ -143,7 +143,7 @@ crc32_reflected_bulk (u32 *pcrc, const byte *inbuf, si
 		      [inbuf_2] "m" (inbuf[2 * 16]),
 		      [inbuf_3] "m" (inbuf[3 * 16]),
 		      [crc] "m" (*pcrc)
-		    : );
+		    );
 
       inbuf += 4 * 16;
       inlen -= 4 * 16;
@@ -151,7 +151,7 @@ crc32_reflected_bulk (u32 *pcrc, const byte *inbuf, si
       asm volatile ("movdqa %[k1k2], %%xmm4\n\t"
 		    :
 		    : [k1k2] "m" (consts->k[1 - 1])
-		    : );
+		    );
 
       /* Fold by 4. */
       while (inlen >= 4 * 16)
@@ -188,7 +188,7 @@ crc32_reflected_bulk (u32 *pcrc, const byte *inbuf, si
 			  [inbuf_1] "m" (inbuf[1 * 16]),
 			  [inbuf_2] "m" (inbuf[2 * 16]),
 			  [inbuf_3] "m" (inbuf[3 * 16])
-			: );
+			);
 
 	  inbuf += 4 * 16;
 	  inlen -= 4 * 16;
@@ -199,7 +199,7 @@ crc32_reflected_bulk (u32 *pcrc, const byte *inbuf, si
 		    :
 		    : [k3k4] "m" (consts->k[3 - 1]),
 		      [my_p] "m" (consts->my_p[0])
-		    : );
+		    );
 
       /* Fold 4 to 1. */
 
@@ -222,7 +222,7 @@ crc32_reflected_bulk (u32 *pcrc, const byte *inbuf, si
 		    "pxor %%xmm4, %%xmm0\n\t"
 		    :
 		    :
-		    : );
+		    );
     }
   else
     {
@@ -236,7 +236,7 @@ crc32_reflected_bulk (u32 *pcrc, const byte *inbuf, si
 		      [crc] "m" (*pcrc),
 		      [k3k4] "m" (consts->k[3 - 1]),
 		      [my_p] "m" (consts->my_p[0])
-		    : );
+		    );
 
       inbuf += 16;
       inlen -= 16;
@@ -256,7 +256,7 @@ crc32_reflected_bulk (u32 *pcrc, const byte *inbuf, si
 			"pxor %%xmm1, %%xmm0\n\t"
 			:
 			: [inbuf] "m" (*inbuf)
-			: );
+			);
 
 	  inbuf += 16;
 	  inlen -= 16;
@@ -288,7 +288,7 @@ crc32_reflected_bulk (u32 *pcrc, const byte *inbuf, si
 		      [mask] "m" (crc32_partial_fold_input_mask[inlen]),
 		      [shl_shuf] "m" (crc32_refl_shuf_shift[inlen]),
 		      [shr_shuf] "m" (crc32_refl_shuf_shift[inlen + 16])
-		    : );
+		    );
 
       inbuf += inlen;
       inlen -= inlen;
@@ -318,7 +318,7 @@ crc32_reflected_bulk (u32 *pcrc, const byte *inbuf, si
 		"pextrd $2, %%xmm0, %[out]\n\t"
 		: [out] "=m" (*pcrc)
 		: [k5] "m" (consts->k[5 - 1])
-	        : );
+	        );
 }
 
 static inline void
@@ -333,7 +333,7 @@ crc32_reflected_less_than_16 (u32 *pcrc, const byte *i
       asm volatile ("movdqa %[my_p], %%xmm5\n\t"
 		    :
 		    : [my_p] "m" (consts->my_p[0])
-		    : );
+		    );
 
       if (inlen == 1)
 	{
@@ -372,7 +372,7 @@ crc32_reflected_less_than_16 (u32 *pcrc, const byte *i
 		    : [out] "=m" (*pcrc)
 		    : [in] "rm" (data),
 		      [crc] "rm" (crc)
-		    : );
+		    );
     }
   else if (inlen == 4)
     {
@@ -391,7 +391,7 @@ crc32_reflected_less_than_16 (u32 *pcrc, const byte *i
 		    : [in] "m" (*inbuf),
 		      [crc] "m" (*pcrc),
 		      [my_p] "m" (consts->my_p[0])
-		    : );
+		    );
     }
   else
     {
@@ -404,14 +404,14 @@ crc32_reflected_less_than_16 (u32 *pcrc, const byte *i
 		      [crc] "m" (*pcrc),
 		      [my_p] "m" (consts->my_p[0]),
 		      [k3k4] "m" (consts->k[3 - 1])
-		    : );
+		    );
 
       if (inlen >= 8)
 	{
 	  asm volatile ("movq %[inbuf], %%xmm0\n\t"
 			:
 			: [inbuf] "m" (*inbuf)
-			: );
+			);
 	  if (inlen > 8)
 	    {
 	      asm volatile (/*"pinsrq $1, %[inbuf_tail], %%xmm0\n\t"*/
@@ -422,7 +422,7 @@ crc32_reflected_less_than_16 (u32 *pcrc, const byte *i
 			    : [inbuf_tail] "m" (inbuf[inlen - 8]),
 			      [merge_shuf] "m"
 				(*crc32_merge9to15_shuf[inlen - 9])
-			    : );
+			    );
 	    }
 	}
       else
@@ -435,7 +435,7 @@ crc32_reflected_less_than_16 (u32 *pcrc, const byte *i
 			  [inbuf_tail] "m" (inbuf[inlen - 4]),
 			  [merge_shuf] "m"
 			    (*crc32_merge5to7_shuf[inlen - 5])
-			: );
+			);
 	}
 
       /* Final fold. */
@@ -465,7 +465,7 @@ crc32_reflected_less_than_16 (u32 *pcrc, const byte *i
 		    "pextrd $2, %%xmm0, %[out]\n\t"
 		    : [out] "=m" (*pcrc)
 		    : [k5] "m" (consts->k[5 - 1])
-		    : );
+		    );
     }
 }
 
@@ -477,7 +477,7 @@ crc32_bulk (u32 *pcrc, const byte *inbuf, size_t inlen
   asm volatile ("movdqa %[bswap], %%xmm7\n\t"
 		:
 		: [bswap] "m" (*crc32_bswap_shuf)
-		: );
+		);
 
   if (inlen >= 8 * 16)
     {
@@ -497,7 +497,7 @@ crc32_bulk (u32 *pcrc, const byte *inbuf, size_t inlen
 		      [inbuf_2] "m" (inbuf[2 * 16]),
 		      [inbuf_3] "m" (inbuf[3 * 16]),
 		      [crc] "m" (*pcrc)
-		    : );
+		    );
 
       inbuf += 4 * 16;
       inlen -= 4 * 16;
@@ -505,7 +505,7 @@ crc32_bulk (u32 *pcrc, const byte *inbuf, size_t inlen
       asm volatile ("movdqa %[k1k2], %%xmm4\n\t"
 		    :
 		    : [k1k2] "m" (consts->k[1 - 1])
-		    : );
+		    );
 
       /* Fold by 4. */
       while (inlen >= 4 * 16)
@@ -546,7 +546,7 @@ crc32_bulk (u32 *pcrc, const byte *inbuf, size_t inlen
 			  [inbuf_1] "m" (inbuf[1 * 16]),
 			  [inbuf_2] "m" (inbuf[2 * 16]),
 			  [inbuf_3] "m" (inbuf[3 * 16])
-			: );
+			);
 
 	  inbuf += 4 * 16;
 	  inlen -= 4 * 16;
@@ -557,7 +557,7 @@ crc32_bulk (u32 *pcrc, const byte *inbuf, size_t inlen
 		    :
 		    : [k3k4] "m" (consts->k[3 - 1]),
 		      [my_p] "m" (consts->my_p[0])
-		    : );
+		    );
 
       /* Fold 4 to 1. */
 
@@ -580,7 +580,7 @@ crc32_bulk (u32 *pcrc, const byte *inbuf, size_t inlen
 		    "pxor %%xmm4, %%xmm0\n\t"
 		    :
 		    :
-		    : );
+		    );
     }
   else
     {
@@ -595,7 +595,7 @@ crc32_bulk (u32 *pcrc, const byte *inbuf, size_t inlen
 		      [crc] "m" (*pcrc),
 		      [k3k4] "m" (consts->k[3 - 1]),
 		      [my_p] "m" (consts->my_p[0])
-		    : );
+		    );
 
       inbuf += 16;
       inlen -= 16;
@@ -616,7 +616,7 @@ crc32_bulk (u32 *pcrc, const byte *inbuf, size_t inlen
 			"pxor %%xmm1, %%xmm0\n\t"
 			:
 			: [inbuf] "m" (*inbuf)
-			: );
+			);
 
 	  inbuf += 16;
 	  inlen -= 16;
@@ -650,7 +650,7 @@ crc32_bulk (u32 *pcrc, const byte *inbuf, size_t inlen
 		      [mask] "m" (crc32_partial_fold_input_mask[inlen]),
 		      [shl_shuf] "m" (crc32_refl_shuf_shift[32 - inlen]),
 		      [shr_shuf] "m" (crc32_shuf_shift[inlen + 16])
-		    : );
+		    );
 
       inbuf += inlen;
       inlen -= inlen;
@@ -697,7 +697,7 @@ crc32_less_than_16 (u32 *pcrc, const byte *inbuf, size
       asm volatile ("movdqa %[my_p], %%xmm5\n\t"
 		    :
 		    : [my_p] "m" (consts->my_p[0])
-		    : );
+		    );
 
       if (inlen == 1)
 	{
@@ -774,14 +774,14 @@ crc32_less_than_16 (u32 *pcrc, const byte *inbuf, size
 		      [crc] "m" (*pcrc),
 		      [my_p] "m" (consts->my_p[0]),
 		      [k3k4] "m" (consts->k[3 - 1])
-		    : );
+		    );
 
       if (inlen >= 8)
 	{
 	  asm volatile ("movq %[inbuf], %%xmm0\n\t"
 			:
 			: [inbuf] "m" (*inbuf)
-			: );
+			);
 	  if (inlen > 8)
 	    {
 	      asm volatile (/*"pinsrq $1, %[inbuf_tail], %%xmm0\n\t"*/
@@ -792,7 +792,7 @@ crc32_less_than_16 (u32 *pcrc, const byte *inbuf, size
 			    : [inbuf_tail] "m" (inbuf[inlen - 8]),
 			      [merge_shuf] "m"
 				(*crc32_merge9to15_shuf[inlen - 9])
-			    : );
+			    );
 	    }
 	}
       else
@@ -805,7 +805,7 @@ crc32_less_than_16 (u32 *pcrc, const byte *inbuf, size
 			  [inbuf_tail] "m" (inbuf[inlen - 4]),
 			  [merge_shuf] "m"
 			    (*crc32_merge5to7_shuf[inlen - 5])
-			: );
+			);
 	}
 
       /* Final fold. */
