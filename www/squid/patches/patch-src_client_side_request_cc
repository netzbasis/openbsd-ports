$OpenBSD: patch-src_client_side_request_cc,v 1.2 2018/04/19 21:49:35 sthen Exp $

#1   http://www.squid-cache.org/Advisories/SQUID-2018_2.txt
http://www.squid-cache.org/Versions/v3/3.5/changesets/SQUID-2018_2.patch

 Due to incorrect pointer handling Squid is vulnerable to denial
 of service attack when processing ESI responses or downloading
 intermediate CA certificates.

 This problem allows a remote client delivering certain HTTP
 requests in conjunction with certain trusted server responses to
 trigger a denial of service for all clients accessing the Squid
 service.

#2   http://www.squid-cache.org/Advisories/SQUID-2018_3.txt
http://www.squid-cache.org/Versions/v3/3.5/changesets/SQUID-2018_3.patch

 Due to incorrect pointer handling Squid is vulnerable to denial
 of service attack when processing ESI responses.

 This problem allows a remote server delivering ESI responses
 to trigger a denial of service for all clients accessing the
 Squid service.

 This problem is limited to Squid operating as reverse proxy.

Index: src/client_side_request.cc
--- src/client_side_request.cc.orig
+++ src/client_side_request.cc
@@ -488,9 +488,9 @@ clientFollowXForwardedForCheck(allow_t answer, void *d
         * Ensure that the access log shows the indirect client
         * instead of the direct client.
         */
-        ConnStateData *conn = http->getConn();
-        conn->log_addr = request->indirect_client_addr;
-        http->al->cache.caddr = conn->log_addr;
+        http->al->cache.caddr = request->indirect_client_addr;
+        if (ConnStateData *conn = http->getConn())
+            conn->log_addr = request->indirect_client_addr;
     }
     request->x_forwarded_for_iterator.clean();
     request->flags.done_follow_x_forwarded_for = true;
@@ -1419,6 +1419,11 @@ ClientRequestContext::checkNoCacheDone(const allow_t &
 bool
 ClientRequestContext::sslBumpAccessCheck()
 {
+    if (!http->getConn()) {
+        http->al->ssl.bumpMode = Ssl::bumpEnd; // SslBump does not apply; log -
+        return false;
+    }
+
     // If SSL connection tunneling or bumping decision has been made, obey it.
     const Ssl::BumpMode bumpMode = http->getConn()->sslBumpMode;
     if (bumpMode != Ssl::bumpEnd) {
