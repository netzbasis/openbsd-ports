$OpenBSD: patch-src_mod_cgi_c,v 1.8 2016/10/12 08:09:26 ajacoutot Exp $

- [core] fix crash if ready events on abandoned fd (fixes #2748)
- performance: use Linux extended syscalls and flags

--- src/mod_cgi.c.orig	Mon Oct 10 18:05:40 2016
+++ src/mod_cgi.c	Mon Oct 10 18:04:38 2016
@@ -36,6 +36,14 @@
 #include <stdio.h>
 #include <fcntl.h>
 
+#ifdef O_CLOEXEC
+#define pipe_cloexec(pipefd) pipe2((pipefd), O_CLOEXEC)
+#elif defined FD_CLOEXEC
+#define pipe_cloexec(pipefd) (0 == pipe(pipefd) ? fcntl(fd, F_SETFD, FD_CLOEXEC) : -1)
+#else
+#define pipe_cloexec(pipefd) pipe(pipefd)
+#endif
+
 enum {EOL_UNSET, EOL_N, EOL_RN};
 
 typedef struct {
@@ -606,10 +614,7 @@ static void cgi_connection_close_fdtocgi(server *srv, 
 	/*(closes only hctx->fdtocgi)*/
 	fdevent_event_del(srv->ev, &(hctx->fde_ndx_tocgi), hctx->fdtocgi);
 	fdevent_unregister(srv->ev, hctx->fdtocgi);
-
-	if (close(hctx->fdtocgi)) {
-		log_error_write(srv, __FILE__, __LINE__, "sds", "cgi stdin close failed ", hctx->fdtocgi, strerror(errno));
-	}
+	fdevent_sched_close(srv->ev, hctx->fdtocgi, 0);
 	hctx->fdtocgi = -1;
 }
 
@@ -631,10 +636,7 @@ static void cgi_connection_close(server *srv, handler_
 		/* close connection to the cgi-script */
 		fdevent_event_del(srv->ev, &(hctx->fde_ndx), hctx->fd);
 		fdevent_unregister(srv->ev, hctx->fd);
-
-		if (close(hctx->fd)) {
-			log_error_write(srv, __FILE__, __LINE__, "sds", "cgi close failed ", hctx->fd, strerror(errno));
-		}
+		fdevent_sched_close(srv->ev, hctx->fd, 0);
 	}
 
 	if (hctx->fdtocgi != -1) {
@@ -1078,12 +1080,12 @@ static int cgi_create_env(server *srv, connection *con
 		}
 	}
 
-	if (pipe(to_cgi_fds)) {
+	if (pipe_cloexec(to_cgi_fds)) {
 		log_error_write(srv, __FILE__, __LINE__, "ss", "pipe failed:", strerror(errno));
 		return -1;
 	}
 
-	if (pipe(from_cgi_fds)) {
+	if (pipe_cloexec(from_cgi_fds)) {
 		close(to_cgi_fds[0]);
 		close(to_cgi_fds[1]);
 		log_error_write(srv, __FILE__, __LINE__, "ss", "pipe failed:", strerror(errno));
@@ -1105,18 +1107,20 @@ static int cgi_create_env(server *srv, connection *con
 		server_socket *srv_sock = con->srv_socket;
 
 		/* move stdout to from_cgi_fd[1] */
-		close(STDOUT_FILENO);
 		dup2(from_cgi_fds[1], STDOUT_FILENO);
+	      #ifndef FD_CLOEXEC
 		close(from_cgi_fds[1]);
 		/* not needed */
 		close(from_cgi_fds[0]);
+	      #endif
 
 		/* move the stdin to to_cgi_fd[0] */
-		close(STDIN_FILENO);
 		dup2(to_cgi_fds[0], STDIN_FILENO);
+	      #ifndef FD_CLOEXEC
 		close(to_cgi_fds[0]);
 		/* not needed */
 		close(to_cgi_fds[1]);
+	      #endif
 
 		/* create environment */
 		env.ptr = NULL;
@@ -1372,11 +1376,13 @@ static int cgi_create_env(server *srv, connection *con
 		hctx->fd = from_cgi_fds[0];
 		hctx->fde_ndx = -1;
 
+		++srv->cur_fds;
+
 		if (0 == con->request.content_length) {
 			close(to_cgi_fds[1]);
 		} else {
 			/* there is content to send */
-			if (-1 == fdevent_fcntl_set(srv->ev, to_cgi_fds[1])) {
+			if (-1 == fdevent_fcntl_set_nb(srv->ev, to_cgi_fds[1])) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "fcntl failed: ", strerror(errno));
 				close(to_cgi_fds[1]);
 				cgi_connection_close(srv, hctx);
@@ -1388,16 +1394,17 @@ static int cgi_create_env(server *srv, connection *con
 				cgi_connection_close(srv, hctx);
 				return -1;
 			}
+
+			++srv->cur_fds;
 		}
 
 		fdevent_register(srv->ev, hctx->fd, cgi_handle_fdevent, hctx);
-		fdevent_event_set(srv->ev, &(hctx->fde_ndx), hctx->fd, FDEVENT_IN);
-
-		if (-1 == fdevent_fcntl_set(srv->ev, hctx->fd)) {
+		if (-1 == fdevent_fcntl_set_nb(srv->ev, hctx->fd)) {
 			log_error_write(srv, __FILE__, __LINE__, "ss", "fcntl failed: ", strerror(errno));
 			cgi_connection_close(srv, hctx);
 			return -1;
 		}
+		fdevent_event_set(srv->ev, &(hctx->fde_ndx), hctx->fd, FDEVENT_IN);
 
 		break;
 	}
