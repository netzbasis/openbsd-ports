$OpenBSD: patch-src_fdevent_c,v 1.2 2016/10/12 08:09:26 ajacoutot Exp $

- [core] check if client half-closed TCP if POLLHUP (#2743)
- [core] fix crash if ready events on abandoned fd (fixes #2748)
- performance: use Linux extended syscalls and flags

--- src/fdevent.c.orig	Mon Oct 10 18:05:27 2016
+++ src/fdevent.c	Mon Oct 10 18:04:38 2016
@@ -23,6 +23,7 @@ fdevents *fdevent_init(server *srv, size_t maxfds, fde
 	ev->fdarray = calloc(maxfds, sizeof(*ev->fdarray));
 	force_assert(NULL != ev->fdarray);
 	ev->maxfds = maxfds;
+	ev->highfd = -1;
 
 	switch(type) {
 	case FDEVENT_HANDLER_POLL:
@@ -94,7 +95,7 @@ void fdevent_free(fdevents *ev) {
 	if (ev->free) ev->free(ev);
 
 	for (i = 0; i < ev->maxfds; i++) {
-		if (ev->fdarray[i]) free(ev->fdarray[i]);
+		if (ev->fdarray[i] > (fdnode *)0x2) free(ev->fdarray[i]);
 	}
 
 	free(ev->fdarray);
@@ -148,9 +149,42 @@ int fdevent_unregister(fdevents *ev, int fd) {
 	return 0;
 }
 
+void fdevent_sched_close(fdevents *ev, int fd, int issock) {
+	if (!ev) return;
+	ev->fdarray[fd] = (issock ? (fdnode *)0x1 : (fdnode *)0x2);
+	if (ev->highfd < fd) ev->highfd = fd;
+}
+
+void fdevent_sched_run(server *srv, fdevents *ev) {
+	const int highfd = ev->highfd;
+	for (int fd = 0; fd <= highfd; ++fd) {
+		fdnode * const fdn = ev->fdarray[fd];
+		int rc;
+		if (!((uintptr_t)fdn & 0x3)) continue;
+	      #ifdef _WIN32
+		if (fdn == (fdnode *)0x1) {
+			rc = closesocket(fd);
+		}
+		else if (fdn == (fdnode)0x2) {
+			rc = close(fd);
+		}
+	      #else
+		rc = close(fd);
+	      #endif
+
+		if (0 != rc) {
+			log_error_write(srv, __FILE__, __LINE__, "sds", "close failed ", fd, strerror(errno));
+		}
+
+		ev->fdarray[fd] = NULL;
+		--srv->cur_fds;
+	}
+	ev->highfd = -1;
+}
+
 void fdevent_event_del(fdevents *ev, int *fde_ndx, int fd) {
 	if (-1 == fd) return;
-	if (NULL == ev->fdarray[fd]) return;
+	if (ev->fdarray[fd] <= (fdnode *)0x2) return;
 
 	if (ev->event_del) *fde_ndx = ev->event_del(ev, *fde_ndx, fd);
 	ev->fdarray[fd]->events = 0;
@@ -212,6 +246,7 @@ int fdevent_event_get_fd(fdevents *ev, size_t ndx) {
 
 fdevent_handler fdevent_get_handler(fdevents *ev, int fd) {
 	if (ev->fdarray[fd] == NULL) SEGFAULT();
+	if ((uintptr_t)ev->fdarray[fd] & 0x3) return NULL;
 	if (ev->fdarray[fd]->fd != fd) SEGFAULT();
 
 	return ev->fdarray[fd]->handler;
@@ -219,6 +254,7 @@ fdevent_handler fdevent_get_handler(fdevents *ev, int 
 
 void * fdevent_get_context(fdevents *ev, int fd) {
 	if (ev->fdarray[fd] == NULL) SEGFAULT();
+	if ((uintptr_t)ev->fdarray[fd] & 0x3) return NULL;
 	if (ev->fdarray[fd]->fd != fd) SEGFAULT();
 
 	return ev->fdarray[fd]->ctx;
@@ -234,7 +270,10 @@ void fd_close_on_exec(int fd) {
 }
 
 int fdevent_fcntl_set(fdevents *ev, int fd) {
-	fd_close_on_exec(fd);
+	return ((ev) && (ev->fcntl_set)) ? ev->fcntl_set(ev, fd) : 0;
+}
+
+int fdevent_fcntl_set_nb(fdevents *ev, int fd) {
 	if ((ev) && (ev->fcntl_set)) return ev->fcntl_set(ev, fd);
 #ifdef O_NONBLOCK
 	return fcntl(fd, F_SETFL, O_NONBLOCK | O_RDWR);
@@ -243,10 +282,105 @@ int fdevent_fcntl_set(fdevents *ev, int fd) {
 #endif
 }
 
+int fdevent_fcntl_set_nb_cloexec(fdevents *ev, int fd) {
+	fd_close_on_exec(fd);
+	return fdevent_fcntl_set_nb(ev, fd);
+}
 
+int fdevent_fcntl_set_nb_cloexec_sock(fdevents *ev, int fd) {
+#if defined(SOCK_CLOEXEC) && defined(SOCK_NONBLOCK)
+	return ((ev) && (ev->fcntl_set)) ? ev->fcntl_set(ev, fd) : 0;
+#else
+	return fdevent_fcntl_set_nb_cloexec(ev, fd);
+#endif
+}
+
+int fdevent_socket_cloexec(int domain, int type, int protocol) {
+#ifdef SOCK_CLOEXEC
+	return socket(domain, type | SOCK_CLOEXEC, protocol);
+#else
+	int fd;
+	if (-1 != (fd = socket(domain, type, protocol))) {
+#ifdef FD_CLOEXEC
+		fcntl(fd, F_SETFD, FD_CLOEXEC);
+#endif
+	}
+	return fd;
+#endif
+}
+
+int fdevent_socket_nb_cloexec(int domain, int type, int protocol) {
+#ifdef SOCK_CLOEXEC
+	return socket(domain, type | SOCK_CLOEXEC | SOCK_NONBLOCK, protocol);
+#else
+	int fd;
+	if (-1 != (fd = socket(domain, type, protocol))) {
+#ifdef FD_CLOEXEC
+		fcntl(fd, F_SETFD, FD_CLOEXEC);
+#endif
+#ifdef O_NONBLOCK
+		fcntl(fd, F_SETFL, O_NONBLOCK | O_RDWR);
+#endif
+	}
+	return fd;
+#endif
+}
+
+#ifndef O_NOCTTY
+#define O_NOCTTY 0
+#endif
+
+int fdevent_open_cloexec(const char *pathname, int flags, mode_t mode) {
+#ifdef O_CLOEXEC
+	return open(pathname, flags | O_CLOEXEC | O_NOCTTY, mode);
+#else
+	int fd = open(pathname, flags | O_NOCTTY, mode);
+#ifdef FD_CLOEXEC
+	if (fd != -1)
+		fcntl(fd, F_SETFD, FD_CLOEXEC);
+#endif
+	return fd;
+#endif
+}
+
+
 int fdevent_event_next_fdndx(fdevents *ev, int ndx) {
 	if (ev->event_next_fdndx) return ev->event_next_fdndx(ev, ndx);
 
 	return -1;
 }
 
+
+#include <netinet/tcp.h>
+#if (defined(__APPLE__) && defined(__MACH__)) \
+  || defined(__FreeBSD__) || defined(__NetBSD__) \
+  || defined(__OpenBSD__) || defined(__DragonflyBSD__)
+#include <netinet/tcp_fsm.h>
+#endif
+
+/* fd must be TCP socket (AF_INET, AF_INET6), end-of-stream recv() 0 bytes */
+int fdevent_is_tcp_half_closed(int fd) {
+  #ifdef TCP_CONNECTION_INFO     /* Darwin */
+    struct tcp_connection_info tcpi;
+    socklen_t tlen = sizeof(tcpi);
+    return (0 == getsockopt(fd, IPPROTO_TCP, TCP_CONNECTION_INFO, &tcpi, &tlen)
+            && tcpi.tcpi_state == TCPS_CLOSE_WAIT);
+  #elif defined(TCP_INFO) && defined(TCPS_CLOSE_WAIT)
+    /* FreeBSD, NetBSD (not present in OpenBSD) */
+    struct tcp_info tcpi;
+    socklen_t tlen = sizeof(tcpi);
+    return (0 == getsockopt(fd, IPPROTO_TCP, TCP_INFO, &tcpi, &tlen)
+            && tcpi.tcpi_state == TCPS_CLOSE_WAIT);
+  #elif defined(TCP_INFO) && defined(__linux__)
+    /* Linux */
+    struct tcp_info tcpi;
+    socklen_t tlen = sizeof(tcpi);/*SOL_TCP == IPPROTO_TCP*/
+    return (0 == getsockopt(fd,     SOL_TCP, TCP_INFO, &tcpi, &tlen)
+            && tcpi.tcpi_state == TCP_CLOSE_WAIT);
+  #else
+    UNUSED(fd);
+    /*(0 != getpeername() error might indicate TCP RST, but success
+     * would not differentiate between half-close and full-close)*/
+    return 0; /* false (not half-closed) or TCP state unknown */
+  #endif
+}
