$OpenBSD: patch-content_gpu_gpu_main_cc,v 1.6 2015/12/17 07:02:48 robert Exp $
--- content/gpu/gpu_main.cc.orig.port	Tue Nov 24 21:00:55 2015
+++ content/gpu/gpu_main.cc	Wed Dec  2 08:18:32 2015
@@ -93,7 +93,7 @@ bool WarmUpSandbox(const base::CommandLine& command_li
 bool CollectGraphicsInfo(gpu::GPUInfo& gpu_info);
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #if !defined(OS_CHROMEOS)
 bool CanAccessNvidiaDeviceFile();
 #endif
@@ -171,13 +171,13 @@ int GpuMain(const MainFunctionParams& parameters) {
   // Use a UI message loop because ANGLE and the desktop GL platform can
   // create child windows to render to.
   base::MessageLoop main_message_loop(base::MessageLoop::TYPE_UI);
-#elif defined(OS_LINUX) && defined(USE_X11)
+#elif (defined(OS_BSD) || defined(OS_LINUX)) && defined(USE_X11)
   // We need a UI loop so that we can grab the Expose events. See GLSurfaceGLX
   // and https://crbug.com/326995.
   base::MessageLoop main_message_loop(base::MessageLoop::TYPE_UI);
   scoped_ptr<ui::PlatformEventSource> event_source =
       ui::PlatformEventSource::CreateDefault();
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   base::MessageLoop main_message_loop(base::MessageLoop::TYPE_DEFAULT);
 #elif defined(OS_MACOSX)
   // This is necessary for CoreAnimation layers hosted in the GPU process to be
@@ -249,6 +249,10 @@ int GpuMain(const MainFunctionParams& parameters) {
       initialized_sandbox = true;
     }
 #endif  // defined(OS_LINUX)
+#if defined(OS_BSD)
+    bool initialized_gl_context = false;
+    bool should_initialize_gl_context = false;
+#endif
 
     base::TimeTicks before_initialize_one_off = base::TimeTicks::Now();
 
@@ -296,7 +300,7 @@ int GpuMain(const MainFunctionParams& parameters) {
       }
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
       initialized_gl_context = true;
 #if !defined(OS_CHROMEOS)
       if (gpu_info.gpu.vendor_id == 0x10de &&  // NVIDIA
@@ -335,14 +339,16 @@ int GpuMain(const MainFunctionParams& parameters) {
       watchdog_thread = NULL;
     }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     should_initialize_gl_context = !initialized_gl_context &&
                                    !dead_on_arrival;
 
+#if !defined(OS_BSD)
     if (!initialized_sandbox) {
       gpu_info.sandboxed = StartSandboxLinux(gpu_info, watchdog_thread.get(),
                                              should_initialize_gl_context);
     }
+#endif
 #elif defined(OS_WIN)
     gpu_info.sandboxed = StartSandboxWindows(parameters.sandbox_info);
 #elif defined(OS_MACOSX)
@@ -447,7 +453,7 @@ bool CollectGraphicsInfo(gpu::GPUInfo& gpu_info) {
 }
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #if !defined(OS_CHROMEOS)
 bool CanAccessNvidiaDeviceFile() {
   bool res = true;
